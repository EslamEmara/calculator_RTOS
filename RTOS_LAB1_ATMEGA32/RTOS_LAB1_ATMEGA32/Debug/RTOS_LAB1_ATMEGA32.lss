
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000239a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000044  00800060  0000239a  0000242e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000674  008000a4  008000a4  00002472  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002472  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000024d0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000330  00000000  00000000  0000250c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003fd2  00000000  00000000  0000283c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001272  00000000  00000000  0000680e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002146  00000000  00000000  00007a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008ec  00000000  00000000  00009bc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000011b9  00000000  00000000  0000a4b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003098  00000000  00000000  0000b66d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000318  00000000  00000000  0000e705  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
       4:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       8:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      18:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      1c:	0c 94 91 03 	jmp	0x722	; 0x722 <__vector_7>
      20:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      24:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      28:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      2c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      34:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      3c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      40:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      54:	31 01       	movw	r6, r2
      56:	11 01       	movw	r2, r2
      58:	13 01       	movw	r2, r6
      5a:	15 01       	movw	r2, r10
      5c:	17 01       	movw	r2, r14
      5e:	19 01       	movw	r2, r18
      60:	1b 01       	movw	r2, r22
      62:	1d 01       	movw	r2, r26
      64:	1f 01       	movw	r2, r30
      66:	21 01       	movw	r4, r2
      68:	23 01       	movw	r4, r6
      6a:	25 01       	movw	r4, r10
      6c:	27 01       	movw	r4, r14
      6e:	29 01       	movw	r4, r18
      70:	2b 01       	movw	r4, r22
      72:	2d 01       	movw	r4, r26

00000074 <__ctors_end>:
      74:	11 24       	eor	r1, r1
      76:	1f be       	out	0x3f, r1	; 63
      78:	cf e5       	ldi	r28, 0x5F	; 95
      7a:	d8 e0       	ldi	r29, 0x08	; 8
      7c:	de bf       	out	0x3e, r29	; 62
      7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
      80:	10 e0       	ldi	r17, 0x00	; 0
      82:	a0 e6       	ldi	r26, 0x60	; 96
      84:	b0 e0       	ldi	r27, 0x00	; 0
      86:	ea e9       	ldi	r30, 0x9A	; 154
      88:	f3 e2       	ldi	r31, 0x23	; 35
      8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
      8c:	05 90       	lpm	r0, Z+
      8e:	0d 92       	st	X+, r0
      90:	a4 3a       	cpi	r26, 0xA4	; 164
      92:	b1 07       	cpc	r27, r17
      94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
      96:	27 e0       	ldi	r18, 0x07	; 7
      98:	a4 ea       	ldi	r26, 0xA4	; 164
      9a:	b0 e0       	ldi	r27, 0x00	; 0
      9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
      9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
      a0:	a8 31       	cpi	r26, 0x18	; 24
      a2:	b2 07       	cpc	r27, r18
      a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
      a6:	0e 94 0d 07 	call	0xe1a	; 0xe1a <main>
      aa:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <_exit>

000000ae <__bad_interrupt>:
      ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <DIO_voidSetPort>:
	}
}

void DIO_voidSetPort(u8 Local_PortNumber,u8 Local_Value)
{
    if(Local_PortNumber == 0)
      b2:	81 11       	cpse	r24, r1
      b4:	02 c0       	rjmp	.+4      	; 0xba <DIO_voidSetPort+0x8>
	{
	    PORTA = Local_Value;
      b6:	6b bb       	out	0x1b, r22	; 27
      b8:	08 95       	ret

    }else if(Local_PortNumber == 1)
      ba:	81 30       	cpi	r24, 0x01	; 1
      bc:	11 f4       	brne	.+4      	; 0xc2 <DIO_voidSetPort+0x10>
    {
        PORTB = Local_Value;
      be:	68 bb       	out	0x18, r22	; 24
      c0:	08 95       	ret
    }else if(Local_PortNumber == 2)
      c2:	82 30       	cpi	r24, 0x02	; 2
      c4:	11 f4       	brne	.+4      	; 0xca <DIO_voidSetPort+0x18>
    {
        PORTC = Local_Value;
      c6:	65 bb       	out	0x15, r22	; 21
      c8:	08 95       	ret
    }else if(Local_PortNumber == 3)
      ca:	83 30       	cpi	r24, 0x03	; 3
      cc:	09 f4       	brne	.+2      	; 0xd0 <DIO_voidSetPort+0x1e>
    {
        PORTD = Local_Value;
      ce:	62 bb       	out	0x12, r22	; 18
      d0:	08 95       	ret

000000d2 <DIO_voidSetPortDir>:

}

void DIO_voidSetPortDir(u8 Local_PortNumber, u8 Local_Dir)
{
    if(Local_PortNumber == 0)
      d2:	81 11       	cpse	r24, r1
      d4:	02 c0       	rjmp	.+4      	; 0xda <DIO_voidSetPortDir+0x8>
	{
	    DDRA = Local_Dir;
      d6:	6a bb       	out	0x1a, r22	; 26
      d8:	08 95       	ret

    }else if(Local_PortNumber == 1)
      da:	81 30       	cpi	r24, 0x01	; 1
      dc:	11 f4       	brne	.+4      	; 0xe2 <DIO_voidSetPortDir+0x10>
    {
        DDRB = Local_Dir;
      de:	67 bb       	out	0x17, r22	; 23
      e0:	08 95       	ret
    }else if(Local_PortNumber == 2)
      e2:	82 30       	cpi	r24, 0x02	; 2
      e4:	11 f4       	brne	.+4      	; 0xea <DIO_voidSetPortDir+0x18>
    {
        DDRC = Local_Dir;
      e6:	64 bb       	out	0x14, r22	; 20
      e8:	08 95       	ret
    }else if(Local_PortNumber == 3)
      ea:	83 30       	cpi	r24, 0x03	; 3
      ec:	09 f4       	brne	.+2      	; 0xf0 <DIO_voidSetPortDir+0x1e>
    {
        DDRD = Local_Dir;
      ee:	61 bb       	out	0x11, r22	; 17
      f0:	08 95       	ret

000000f2 <DIO_u8GetPin>:

u8 DIO_u8GetPin(u8 Local_PinNumber)
{
	u8 ret=DIO_LOW;

	if(Local_PinNumber <8)
      f2:	88 30       	cpi	r24, 0x08	; 8
      f4:	58 f4       	brcc	.+22     	; 0x10c <DIO_u8GetPin+0x1a>
	{
		if(GETBIT(PINA,Local_PinNumber)==1)
      f6:	29 b3       	in	r18, 0x19	; 25
		{
			ret = DIO_HIGH;
		}
		else
		{
			ret = DIO_LOW;
      f8:	30 e0       	ldi	r19, 0x00	; 0
      fa:	a9 01       	movw	r20, r18
      fc:	02 c0       	rjmp	.+4      	; 0x102 <DIO_u8GetPin+0x10>
      fe:	55 95       	asr	r21
     100:	47 95       	ror	r20
     102:	8a 95       	dec	r24
     104:	e2 f7       	brpl	.-8      	; 0xfe <DIO_u8GetPin+0xc>
     106:	ca 01       	movw	r24, r20
     108:	81 70       	andi	r24, 0x01	; 1
     10a:	08 95       	ret
		}
	}
	else if(Local_PinNumber <16)
     10c:	80 31       	cpi	r24, 0x10	; 16
     10e:	60 f4       	brcc	.+24     	; 0x128 <DIO_u8GetPin+0x36>
	{
		if(GETBIT(PINB,Local_PinNumber-8)==1)
     110:	26 b3       	in	r18, 0x16	; 22
		{
			ret = DIO_HIGH;
		}
		else
		{
			ret = DIO_LOW;
     112:	30 e0       	ldi	r19, 0x00	; 0
     114:	88 50       	subi	r24, 0x08	; 8
     116:	a9 01       	movw	r20, r18
     118:	02 c0       	rjmp	.+4      	; 0x11e <DIO_u8GetPin+0x2c>
     11a:	55 95       	asr	r21
     11c:	47 95       	ror	r20
     11e:	8a 95       	dec	r24
     120:	e2 f7       	brpl	.-8      	; 0x11a <DIO_u8GetPin+0x28>
     122:	ca 01       	movw	r24, r20
     124:	81 70       	andi	r24, 0x01	; 1
     126:	08 95       	ret
		else
		{
			ret = DIO_LOW;
		}
	}
	else if(Local_PinNumber <24)
     128:	88 31       	cpi	r24, 0x18	; 24
     12a:	60 f4       	brcc	.+24     	; 0x144 <DIO_u8GetPin+0x52>
	{
		if(GETBIT(PINC,Local_PinNumber-16)==1)
     12c:	23 b3       	in	r18, 0x13	; 19
		{
			ret = DIO_HIGH;
		}
		else
		{
			ret = DIO_LOW;
     12e:	30 e0       	ldi	r19, 0x00	; 0
     130:	80 51       	subi	r24, 0x10	; 16
     132:	a9 01       	movw	r20, r18
     134:	02 c0       	rjmp	.+4      	; 0x13a <DIO_u8GetPin+0x48>
     136:	55 95       	asr	r21
     138:	47 95       	ror	r20
     13a:	8a 95       	dec	r24
     13c:	e2 f7       	brpl	.-8      	; 0x136 <DIO_u8GetPin+0x44>
     13e:	ca 01       	movw	r24, r20
     140:	81 70       	andi	r24, 0x01	; 1
     142:	08 95       	ret
		else
		{
			ret = DIO_LOW;
		}
	}
	else if(Local_PinNumber <32)
     144:	80 32       	cpi	r24, 0x20	; 32
     146:	60 f4       	brcc	.+24     	; 0x160 <DIO_u8GetPin+0x6e>
	{
		if(GETBIT(PIND,Local_PinNumber-24)==1)
     148:	20 b3       	in	r18, 0x10	; 16
		{
			ret = DIO_HIGH;
		}
		else
		{
			ret = DIO_LOW;
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	88 51       	subi	r24, 0x18	; 24
     14e:	a9 01       	movw	r20, r18
     150:	02 c0       	rjmp	.+4      	; 0x156 <DIO_u8GetPin+0x64>
     152:	55 95       	asr	r21
     154:	47 95       	ror	r20
     156:	8a 95       	dec	r24
     158:	e2 f7       	brpl	.-8      	; 0x152 <DIO_u8GetPin+0x60>
     15a:	ca 01       	movw	r24, r20
     15c:	81 70       	andi	r24, 0x01	; 1
     15e:	08 95       	ret
    }
}

u8 DIO_u8GetPin(u8 Local_PinNumber)
{
	u8 ret=DIO_LOW;
     160:	80 e0       	ldi	r24, 0x00	; 0
		{
			ret = DIO_LOW;
		}
	}
	return ret;
}
     162:	08 95       	ret

00000164 <DIO_u8GetPinInPort>:

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;

    if(Local_PortNumber == 0)
     164:	81 11       	cpse	r24, r1
     166:	09 c0       	rjmp	.+18     	; 0x17a <DIO_u8GetPinInPort+0x16>
	{
	    ret = GETBIT(PINA, Local_PinNumber);
     168:	89 b3       	in	r24, 0x19	; 25
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	02 c0       	rjmp	.+4      	; 0x172 <DIO_u8GetPinInPort+0xe>
     16e:	95 95       	asr	r25
     170:	87 95       	ror	r24
     172:	6a 95       	dec	r22
     174:	e2 f7       	brpl	.-8      	; 0x16e <DIO_u8GetPinInPort+0xa>
     176:	81 70       	andi	r24, 0x01	; 1
     178:	08 95       	ret

    }else if(Local_PortNumber == 1)
     17a:	81 30       	cpi	r24, 0x01	; 1
     17c:	49 f4       	brne	.+18     	; 0x190 <DIO_u8GetPinInPort+0x2c>
    {
	    ret = GETBIT(PINB, Local_PinNumber);
     17e:	86 b3       	in	r24, 0x16	; 22
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	02 c0       	rjmp	.+4      	; 0x188 <DIO_u8GetPinInPort+0x24>
     184:	95 95       	asr	r25
     186:	87 95       	ror	r24
     188:	6a 95       	dec	r22
     18a:	e2 f7       	brpl	.-8      	; 0x184 <DIO_u8GetPinInPort+0x20>
     18c:	81 70       	andi	r24, 0x01	; 1
     18e:	08 95       	ret

    }else if(Local_PortNumber == 2)
     190:	82 30       	cpi	r24, 0x02	; 2
     192:	49 f4       	brne	.+18     	; 0x1a6 <DIO_u8GetPinInPort+0x42>
    {
	    ret = GETBIT(PINC, Local_PinNumber);
     194:	83 b3       	in	r24, 0x13	; 19
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	02 c0       	rjmp	.+4      	; 0x19e <DIO_u8GetPinInPort+0x3a>
     19a:	95 95       	asr	r25
     19c:	87 95       	ror	r24
     19e:	6a 95       	dec	r22
     1a0:	e2 f7       	brpl	.-8      	; 0x19a <DIO_u8GetPinInPort+0x36>
     1a2:	81 70       	andi	r24, 0x01	; 1
     1a4:	08 95       	ret

    }else if(Local_PortNumber == 3)
     1a6:	83 30       	cpi	r24, 0x03	; 3
     1a8:	49 f4       	brne	.+18     	; 0x1bc <DIO_u8GetPinInPort+0x58>
    {
	    ret = GETBIT(PIND, Local_PinNumber);
     1aa:	80 b3       	in	r24, 0x10	; 16
     1ac:	90 e0       	ldi	r25, 0x00	; 0
     1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <DIO_u8GetPinInPort+0x50>
     1b0:	95 95       	asr	r25
     1b2:	87 95       	ror	r24
     1b4:	6a 95       	dec	r22
     1b6:	e2 f7       	brpl	.-8      	; 0x1b0 <DIO_u8GetPinInPort+0x4c>
     1b8:	81 70       	andi	r24, 0x01	; 1
     1ba:	08 95       	ret
	return ret;
}

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;
     1bc:	80 e0       	ldi	r24, 0x00	; 0
	    ret = GETBIT(PIND, Local_PinNumber);
    }

    return ret;

}
     1be:	08 95       	ret

000001c0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1c0:	cf 93       	push	r28
     1c2:	df 93       	push	r29
     1c4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     1c6:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     1ca:	20 91 a4 00 	lds	r18, 0x00A4	; 0x8000a4 <__data_end>
     1ce:	30 91 a5 00 	lds	r19, 0x00A5	; 0x8000a5 <__data_end+0x1>
     1d2:	c9 01       	movw	r24, r18
     1d4:	8c 0f       	add	r24, r28
     1d6:	9d 1f       	adc	r25, r29
     1d8:	8c 3d       	cpi	r24, 0xDC	; 220
     1da:	45 e0       	ldi	r20, 0x05	; 5
     1dc:	94 07       	cpc	r25, r20
     1de:	58 f4       	brcc	.+22     	; 0x1f6 <pvPortMalloc+0x36>
     1e0:	28 17       	cp	r18, r24
     1e2:	39 07       	cpc	r19, r25
     1e4:	58 f4       	brcc	.+22     	; 0x1fc <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     1e6:	e9 01       	movw	r28, r18
     1e8:	ca 55       	subi	r28, 0x5A	; 90
     1ea:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     1ec:	90 93 a5 00 	sts	0x00A5, r25	; 0x8000a5 <__data_end+0x1>
     1f0:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <__data_end>
     1f4:	05 c0       	rjmp	.+10     	; 0x200 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     1f6:	c0 e0       	ldi	r28, 0x00	; 0
     1f8:	d0 e0       	ldi	r29, 0x00	; 0
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <pvPortMalloc+0x40>
     1fc:	c0 e0       	ldi	r28, 0x00	; 0
     1fe:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     200:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     204:	ce 01       	movw	r24, r28
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	08 95       	ret

0000020c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     20c:	08 95       	ret

0000020e <KeyPad_u8AdjustKeyNumber_4x4>:

}

u8 KeyPad_u8AdjustKeyNumber_4x4(u8 button_number)
{
    switch(button_number)
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	fc 01       	movw	r30, r24
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	e0 31       	cpi	r30, 0x10	; 16
     216:	f1 05       	cpc	r31, r1
     218:	10 f5       	brcc	.+68     	; 0x25e <KeyPad_u8AdjustKeyNumber_4x4+0x50>
     21a:	e6 5d       	subi	r30, 0xD6	; 214
     21c:	ff 4f       	sbci	r31, 0xFF	; 255
     21e:	0c 94 82 0e 	jmp	0x1d04	; 0x1d04 <__tablejump2__>
	{
		case 1: return '7';
				break;
		case 2: return '8';
     222:	88 e3       	ldi	r24, 0x38	; 56
     224:	08 95       	ret
				break;
		case 3: return '9';
     226:	89 e3       	ldi	r24, 0x39	; 57
     228:	08 95       	ret
				break;
		case 4: return '/'; // ASCII Code of %
     22a:	8f e2       	ldi	r24, 0x2F	; 47
     22c:	08 95       	ret
				break;
		case 5: return '4';
     22e:	84 e3       	ldi	r24, 0x34	; 52
     230:	08 95       	ret
				break;
		case 6: return '5';
     232:	85 e3       	ldi	r24, 0x35	; 53
     234:	08 95       	ret
				break;
		case 7: return '6';
     236:	86 e3       	ldi	r24, 0x36	; 54
     238:	08 95       	ret
				break;
		case 8: return '*'; /* ASCII Code of '*' */
     23a:	8a e2       	ldi	r24, 0x2A	; 42
     23c:	08 95       	ret
				break;
		case 9: return '1';
     23e:	81 e3       	ldi	r24, 0x31	; 49
     240:	08 95       	ret
				break;
		case 10: return '2';
     242:	82 e3       	ldi	r24, 0x32	; 50
     244:	08 95       	ret
				break;
		case 11: return '3';
     246:	83 e3       	ldi	r24, 0x33	; 51
     248:	08 95       	ret
				break;
		case 12: return '-'; /* ASCII Code of '-' */
     24a:	8d e2       	ldi	r24, 0x2D	; 45
     24c:	08 95       	ret
				break;
		case 13: return 13;  /* ASCII of Enter */
     24e:	8d e0       	ldi	r24, 0x0D	; 13
     250:	08 95       	ret
				break;
		case 14: return '0';
     252:	80 e3       	ldi	r24, 0x30	; 48
     254:	08 95       	ret
				break;
		case 15: return '='; /* ASCII Code of '=' */
     256:	8d e3       	ldi	r24, 0x3D	; 61
     258:	08 95       	ret
				break;
		case 16: return '+'; /* ASCII Code of '+' */
     25a:	8b e2       	ldi	r24, 0x2B	; 43
     25c:	08 95       	ret
				break;
		default: return NO_KEY_PRESSED;
     25e:	8f ef       	ldi	r24, 0xFF	; 255
     260:	08 95       	ret

u8 KeyPad_u8AdjustKeyNumber_4x4(u8 button_number)
{
    switch(button_number)
	{
		case 1: return '7';
     262:	87 e3       	ldi	r24, 0x37	; 55
		case 16: return '+'; /* ASCII Code of '+' */
				break;
		default: return NO_KEY_PRESSED;
	}

}
     264:	08 95       	ret

00000266 <KeyPad_u8GetPressedKey>:
#include "KeyPad_priv.h"
#include "KeyPad_config.h"
#include "KeyPad_int.h"

u8 KeyPad_u8GetPressedKey(void)
{
     266:	cf 92       	push	r12
     268:	df 92       	push	r13
     26a:	ff 92       	push	r15
     26c:	0f 93       	push	r16
     26e:	1f 93       	push	r17
     270:	cf 93       	push	r28
     272:	df 93       	push	r29
     274:	00 e0       	ldi	r16, 0x00	; 0
     276:	10 e0       	ldi	r17, 0x00	; 0
        /*
         * Each time only one of the column pins will be output and
         * the rest will be input pins including the row pins
         */

        DIO_voidSetPortDir(KEYPAD_PORT, (0b00010000<<col));
     278:	68 94       	set
     27a:	cc 24       	eor	r12, r12
     27c:	c4 f8       	bld	r12, 4
     27e:	d1 2c       	mov	r13, r1
     280:	f0 2e       	mov	r15, r16
     282:	e6 01       	movw	r28, r12
     284:	00 2e       	mov	r0, r16
     286:	02 c0       	rjmp	.+4      	; 0x28c <KeyPad_u8GetPressedKey+0x26>
     288:	cc 0f       	add	r28, r28
     28a:	dd 1f       	adc	r29, r29
     28c:	0a 94       	dec	r0
     28e:	e2 f7       	brpl	.-8      	; 0x288 <KeyPad_u8GetPressedKey+0x22>
     290:	6c 2f       	mov	r22, r28
     292:	82 e0       	ldi	r24, 0x02	; 2
     294:	0e 94 69 00 	call	0xd2	; 0xd2 <DIO_voidSetPortDir>

        /*
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));
     298:	6c 2f       	mov	r22, r28
     29a:	60 95       	com	r22
     29c:	82 e0       	ldi	r24, 0x02	; 2
     29e:	0e 94 59 00 	call	0xb2	; 0xb2 <DIO_voidSetPort>

        for(row=0; row<N_row; row++) /* loop for rows */
     2a2:	c0 e0       	ldi	r28, 0x00	; 0
        {
            if(DIO_u8GetPinInPort(KEYPAD_PORT, row) == 0) /* if the switch is pressed in this row */
     2a4:	6c 2f       	mov	r22, r28
     2a6:	82 e0       	ldi	r24, 0x02	; 2
     2a8:	0e 94 b2 00 	call	0x164	; 0x164 <DIO_u8GetPinInPort>
     2ac:	81 11       	cpse	r24, r1
     2ae:	08 c0       	rjmp	.+16     	; 0x2c0 <KeyPad_u8GetPressedKey+0x5a>
	
                #if (N_col == 3)
				
                    return KeyPad_u8AdjustKeyNumber_4x3((row*N_col)+col+1);
                #elif (N_col == 4)
                    return KeyPad_u8AdjustKeyNumber_4x4((row*N_col)+col+1);
     2b0:	cc 0f       	add	r28, r28
     2b2:	cc 0f       	add	r28, r28
     2b4:	81 e0       	ldi	r24, 0x01	; 1
     2b6:	8f 0d       	add	r24, r15
     2b8:	8c 0f       	add	r24, r28
     2ba:	0e 94 07 01 	call	0x20e	; 0x20e <KeyPad_u8AdjustKeyNumber_4x4>
     2be:	09 c0       	rjmp	.+18     	; 0x2d2 <KeyPad_u8GetPressedKey+0x6c>
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));

        for(row=0; row<N_row; row++) /* loop for rows */
     2c0:	cf 5f       	subi	r28, 0xFF	; 255
     2c2:	c4 30       	cpi	r28, 0x04	; 4
     2c4:	79 f7       	brne	.-34     	; 0x2a4 <KeyPad_u8GetPressedKey+0x3e>
     2c6:	0f 5f       	subi	r16, 0xFF	; 255
     2c8:	1f 4f       	sbci	r17, 0xFF	; 255

u8 KeyPad_u8GetPressedKey(void)
{
    u8 col,row;

    for(col=0; col<N_col; col++) /* loop for columns */
     2ca:	04 30       	cpi	r16, 0x04	; 4
     2cc:	11 05       	cpc	r17, r1
     2ce:	c1 f6       	brne	.-80     	; 0x280 <KeyPad_u8GetPressedKey+0x1a>
                #endif
            }
        }
    }

    return NO_KEY_PRESSED;
     2d0:	8f ef       	ldi	r24, 0xFF	; 255
}
     2d2:	df 91       	pop	r29
     2d4:	cf 91       	pop	r28
     2d6:	1f 91       	pop	r17
     2d8:	0f 91       	pop	r16
     2da:	ff 90       	pop	r15
     2dc:	df 90       	pop	r13
     2de:	cf 90       	pop	r12
     2e0:	08 95       	ret

000002e2 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     2e2:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2e4:	89 ef       	ldi	r24, 0xF9	; 249
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	01 97       	sbiw	r24, 0x01	; 1
     2ea:	f1 f7       	brne	.-4      	; 0x2e8 <enableTrigger+0x6>
     2ec:	00 c0       	rjmp	.+0      	; 0x2ee <enableTrigger+0xc>
     2ee:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     2f0:	c2 9a       	sbi	0x18, 2	; 24
     2f2:	8b ed       	ldi	r24, 0xDB	; 219
     2f4:	95 e0       	ldi	r25, 0x05	; 5
     2f6:	01 97       	sbiw	r24, 0x01	; 1
     2f8:	f1 f7       	brne	.-4      	; 0x2f6 <enableTrigger+0x14>
     2fa:	00 c0       	rjmp	.+0      	; 0x2fc <enableTrigger+0x1a>
     2fc:	00 00       	nop
     2fe:	08 95       	ret

00000300 <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     300:	cf 93       	push	r28
     302:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     304:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     306:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     308:	88 b3       	in	r24, 0x18	; 24
     30a:	8f 70       	andi	r24, 0x0F	; 15
     30c:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     30e:	88 b3       	in	r24, 0x18	; 24
     310:	9c 2f       	mov	r25, r28
     312:	90 7f       	andi	r25, 0xF0	; 240
     314:	89 2b       	or	r24, r25
     316:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     318:	0e 94 71 01 	call	0x2e2	; 0x2e2 <enableTrigger>

	PORTB &=0x0f;
     31c:	88 b3       	in	r24, 0x18	; 24
     31e:	8f 70       	andi	r24, 0x0F	; 15
     320:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     322:	88 b3       	in	r24, 0x18	; 24
     324:	c2 95       	swap	r28
     326:	c0 7f       	andi	r28, 0xF0	; 240
     328:	c8 2b       	or	r28, r24
     32a:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     32c:	0e 94 71 01 	call	0x2e2	; 0x2e2 <enableTrigger>

}
     330:	cf 91       	pop	r28
     332:	08 95       	ret

00000334 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     334:	8f ef       	ldi	r24, 0xFF	; 255
     336:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     338:	84 e0       	ldi	r24, 0x04	; 4
     33a:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     33c:	83 e3       	ldi	r24, 0x33	; 51
     33e:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>
	lcd_sendCommand (0x32);
     342:	82 e3       	ldi	r24, 0x32	; 50
     344:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>
	lcd_sendCommand (0x28);
     348:	88 e2       	ldi	r24, 0x28	; 40
     34a:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     34e:	8c e0       	ldi	r24, 0x0C	; 12
     350:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>
     354:	08 95       	ret

00000356 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     356:	cf 93       	push	r28
     358:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     35a:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     35c:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     35e:	88 b3       	in	r24, 0x18	; 24
     360:	8f 70       	andi	r24, 0x0F	; 15
     362:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     364:	88 b3       	in	r24, 0x18	; 24
     366:	9c 2f       	mov	r25, r28
     368:	90 7f       	andi	r25, 0xF0	; 240
     36a:	89 2b       	or	r24, r25
     36c:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     36e:	0e 94 71 01 	call	0x2e2	; 0x2e2 <enableTrigger>
	
	PORTB &=0x0f;
     372:	88 b3       	in	r24, 0x18	; 24
     374:	8f 70       	andi	r24, 0x0F	; 15
     376:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     378:	88 b3       	in	r24, 0x18	; 24
     37a:	c2 95       	swap	r28
     37c:	c0 7f       	andi	r28, 0xF0	; 240
     37e:	c8 2b       	or	r28, r24
     380:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     382:	0e 94 71 01 	call	0x2e2	; 0x2e2 <enableTrigger>
	

}
     386:	cf 91       	pop	r28
     388:	08 95       	ret

0000038a <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     38a:	81 30       	cpi	r24, 0x01	; 1
     38c:	49 f0       	breq	.+18     	; 0x3a0 <lcd_gotoxy+0x16>
     38e:	28 f0       	brcs	.+10     	; 0x39a <lcd_gotoxy+0x10>
     390:	82 30       	cpi	r24, 0x02	; 2
     392:	49 f0       	breq	.+18     	; 0x3a6 <lcd_gotoxy+0x1c>
     394:	83 30       	cpi	r24, 0x03	; 3
     396:	51 f0       	breq	.+20     	; 0x3ac <lcd_gotoxy+0x22>
     398:	0c c0       	rjmp	.+24     	; 0x3b2 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
     39a:	80 e8       	ldi	r24, 0x80	; 128
     39c:	86 0f       	add	r24, r22
					
		break;
     39e:	0a c0       	rjmp	.+20     	; 0x3b4 <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
     3a0:	80 ec       	ldi	r24, 0xC0	; 192
     3a2:	86 0f       	add	r24, r22

		break;
     3a4:	07 c0       	rjmp	.+14     	; 0x3b4 <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
     3a6:	80 e8       	ldi	r24, 0x80	; 128
     3a8:	86 0f       	add	r24, r22

		break;
     3aa:	04 c0       	rjmp	.+8      	; 0x3b4 <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
     3ac:	80 e8       	ldi	r24, 0x80	; 128
     3ae:	86 0f       	add	r24, r22
		break;
     3b0:	01 c0       	rjmp	.+2      	; 0x3b4 <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     3b2:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     3b4:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>
     3b8:	08 95       	ret

000003ba <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     3ba:	81 e0       	ldi	r24, 0x01	; 1
     3bc:	0e 94 80 01 	call	0x300	; 0x300 <lcd_sendCommand>
     3c0:	08 95       	ret

000003c2 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
     3c2:	cf 93       	push	r28
     3c4:	df 93       	push	r29
     3c6:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     3c8:	88 81       	ld	r24, Y
     3ca:	88 23       	and	r24, r24
     3cc:	31 f0       	breq	.+12     	; 0x3da <lcd_dispString+0x18>
     3ce:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
     3d0:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     3d4:	89 91       	ld	r24, Y+
     3d6:	81 11       	cpse	r24, r1
     3d8:	fb cf       	rjmp	.-10     	; 0x3d0 <lcd_dispString+0xe>
	
	}



}
     3da:	df 91       	pop	r29
     3dc:	cf 91       	pop	r28
     3de:	08 95       	ret

000003e0 <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	ec 01       	movw	r28, r24
     3e6:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     3e8:	64 2f       	mov	r22, r20
     3ea:	0e 94 c5 01 	call	0x38a	; 0x38a <lcd_gotoxy>
	lcd_dispString(ptr);
     3ee:	ce 01       	movw	r24, r28
     3f0:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <lcd_dispString>

	


}
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     3fa:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     3fc:	03 96       	adiw	r24, 0x03	; 3
     3fe:	92 83       	std	Z+2, r25	; 0x02
     400:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     402:	2f ef       	ldi	r18, 0xFF	; 255
     404:	3f ef       	ldi	r19, 0xFF	; 255
     406:	34 83       	std	Z+4, r19	; 0x04
     408:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     40a:	96 83       	std	Z+6, r25	; 0x06
     40c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     40e:	90 87       	std	Z+8, r25	; 0x08
     410:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     412:	10 82       	st	Z, r1
     414:	08 95       	ret

00000416 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     416:	fc 01       	movw	r30, r24
     418:	11 86       	std	Z+9, r1	; 0x09
     41a:	10 86       	std	Z+8, r1	; 0x08
     41c:	08 95       	ret

0000041e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	fc 01       	movw	r30, r24
     424:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     426:	21 81       	ldd	r18, Z+1	; 0x01
     428:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     42a:	e9 01       	movw	r28, r18
     42c:	8a 81       	ldd	r24, Y+2	; 0x02
     42e:	9b 81       	ldd	r25, Y+3	; 0x03
     430:	13 96       	adiw	r26, 0x03	; 3
     432:	9c 93       	st	X, r25
     434:	8e 93       	st	-X, r24
     436:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     438:	81 81       	ldd	r24, Z+1	; 0x01
     43a:	92 81       	ldd	r25, Z+2	; 0x02
     43c:	15 96       	adiw	r26, 0x05	; 5
     43e:	9c 93       	st	X, r25
     440:	8e 93       	st	-X, r24
     442:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     444:	8a 81       	ldd	r24, Y+2	; 0x02
     446:	9b 81       	ldd	r25, Y+3	; 0x03
     448:	ec 01       	movw	r28, r24
     44a:	7d 83       	std	Y+5, r23	; 0x05
     44c:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     44e:	e9 01       	movw	r28, r18
     450:	7b 83       	std	Y+3, r23	; 0x03
     452:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     454:	72 83       	std	Z+2, r23	; 0x02
     456:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     458:	19 96       	adiw	r26, 0x09	; 9
     45a:	fc 93       	st	X, r31
     45c:	ee 93       	st	-X, r30
     45e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     460:	80 81       	ld	r24, Z
     462:	8f 5f       	subi	r24, 0xFF	; 255
     464:	80 83       	st	Z, r24
}
     466:	df 91       	pop	r29
     468:	cf 91       	pop	r28
     46a:	08 95       	ret

0000046c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
     470:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     472:	48 81       	ld	r20, Y
     474:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     476:	4f 3f       	cpi	r20, 0xFF	; 255
     478:	2f ef       	ldi	r18, 0xFF	; 255
     47a:	52 07       	cpc	r21, r18
     47c:	31 f4       	brne	.+12     	; 0x48a <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     47e:	dc 01       	movw	r26, r24
     480:	17 96       	adiw	r26, 0x07	; 7
     482:	ed 91       	ld	r30, X+
     484:	fc 91       	ld	r31, X
     486:	18 97       	sbiw	r26, 0x08	; 8
     488:	17 c0       	rjmp	.+46     	; 0x4b8 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     48a:	fc 01       	movw	r30, r24
     48c:	33 96       	adiw	r30, 0x03	; 3
     48e:	dc 01       	movw	r26, r24
     490:	15 96       	adiw	r26, 0x05	; 5
     492:	2d 91       	ld	r18, X+
     494:	3c 91       	ld	r19, X
     496:	16 97       	sbiw	r26, 0x06	; 6
     498:	d9 01       	movw	r26, r18
     49a:	2d 91       	ld	r18, X+
     49c:	3c 91       	ld	r19, X
     49e:	42 17       	cp	r20, r18
     4a0:	53 07       	cpc	r21, r19
     4a2:	50 f0       	brcs	.+20     	; 0x4b8 <vListInsert+0x4c>
     4a4:	02 80       	ldd	r0, Z+2	; 0x02
     4a6:	f3 81       	ldd	r31, Z+3	; 0x03
     4a8:	e0 2d       	mov	r30, r0
     4aa:	a2 81       	ldd	r26, Z+2	; 0x02
     4ac:	b3 81       	ldd	r27, Z+3	; 0x03
     4ae:	2d 91       	ld	r18, X+
     4b0:	3c 91       	ld	r19, X
     4b2:	42 17       	cp	r20, r18
     4b4:	53 07       	cpc	r21, r19
     4b6:	b0 f7       	brcc	.-20     	; 0x4a4 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4b8:	a2 81       	ldd	r26, Z+2	; 0x02
     4ba:	b3 81       	ldd	r27, Z+3	; 0x03
     4bc:	bb 83       	std	Y+3, r27	; 0x03
     4be:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     4c0:	15 96       	adiw	r26, 0x05	; 5
     4c2:	dc 93       	st	X, r29
     4c4:	ce 93       	st	-X, r28
     4c6:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     4c8:	fd 83       	std	Y+5, r31	; 0x05
     4ca:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     4cc:	d3 83       	std	Z+3, r29	; 0x03
     4ce:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4d0:	99 87       	std	Y+9, r25	; 0x09
     4d2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4d4:	fc 01       	movw	r30, r24
     4d6:	20 81       	ld	r18, Z
     4d8:	2f 5f       	subi	r18, 0xFF	; 255
     4da:	20 83       	st	Z, r18
}
     4dc:	df 91       	pop	r29
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     4e2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4e4:	a2 81       	ldd	r26, Z+2	; 0x02
     4e6:	b3 81       	ldd	r27, Z+3	; 0x03
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	95 81       	ldd	r25, Z+5	; 0x05
     4ec:	15 96       	adiw	r26, 0x05	; 5
     4ee:	9c 93       	st	X, r25
     4f0:	8e 93       	st	-X, r24
     4f2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4f4:	a4 81       	ldd	r26, Z+4	; 0x04
     4f6:	b5 81       	ldd	r27, Z+5	; 0x05
     4f8:	82 81       	ldd	r24, Z+2	; 0x02
     4fa:	93 81       	ldd	r25, Z+3	; 0x03
     4fc:	13 96       	adiw	r26, 0x03	; 3
     4fe:	9c 93       	st	X, r25
     500:	8e 93       	st	-X, r24
     502:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     504:	a0 85       	ldd	r26, Z+8	; 0x08
     506:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     508:	11 96       	adiw	r26, 0x01	; 1
     50a:	8d 91       	ld	r24, X+
     50c:	9c 91       	ld	r25, X
     50e:	12 97       	sbiw	r26, 0x02	; 2
     510:	e8 17       	cp	r30, r24
     512:	f9 07       	cpc	r31, r25
     514:	31 f4       	brne	.+12     	; 0x522 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     516:	84 81       	ldd	r24, Z+4	; 0x04
     518:	95 81       	ldd	r25, Z+5	; 0x05
     51a:	12 96       	adiw	r26, 0x02	; 2
     51c:	9c 93       	st	X, r25
     51e:	8e 93       	st	-X, r24
     520:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     522:	11 86       	std	Z+9, r1	; 0x09
     524:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     526:	8c 91       	ld	r24, X
     528:	81 50       	subi	r24, 0x01	; 1
     52a:	8c 93       	st	X, r24
     52c:	08 95       	ret

0000052e <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     52e:	31 e1       	ldi	r19, 0x11	; 17
     530:	fc 01       	movw	r30, r24
     532:	30 83       	st	Z, r19
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	22 e2       	ldi	r18, 0x22	; 34
     538:	20 83       	st	Z, r18
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	a3 e3       	ldi	r26, 0x33	; 51
     53e:	a0 83       	st	Z, r26
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	60 83       	st	Z, r22
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	70 83       	st	Z, r23
     548:	31 97       	sbiw	r30, 0x01	; 1
     54a:	10 82       	st	Z, r1
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	60 e8       	ldi	r22, 0x80	; 128
     550:	60 83       	st	Z, r22
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	10 82       	st	Z, r1
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	62 e0       	ldi	r22, 0x02	; 2
     55a:	60 83       	st	Z, r22
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	63 e0       	ldi	r22, 0x03	; 3
     560:	60 83       	st	Z, r22
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	64 e0       	ldi	r22, 0x04	; 4
     566:	60 83       	st	Z, r22
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	65 e0       	ldi	r22, 0x05	; 5
     56c:	60 83       	st	Z, r22
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	66 e0       	ldi	r22, 0x06	; 6
     572:	60 83       	st	Z, r22
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	67 e0       	ldi	r22, 0x07	; 7
     578:	60 83       	st	Z, r22
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	68 e0       	ldi	r22, 0x08	; 8
     57e:	60 83       	st	Z, r22
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	69 e0       	ldi	r22, 0x09	; 9
     584:	60 83       	st	Z, r22
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	60 e1       	ldi	r22, 0x10	; 16
     58a:	60 83       	st	Z, r22
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	30 83       	st	Z, r19
     590:	31 97       	sbiw	r30, 0x01	; 1
     592:	32 e1       	ldi	r19, 0x12	; 18
     594:	30 83       	st	Z, r19
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	33 e1       	ldi	r19, 0x13	; 19
     59a:	30 83       	st	Z, r19
     59c:	31 97       	sbiw	r30, 0x01	; 1
     59e:	34 e1       	ldi	r19, 0x14	; 20
     5a0:	30 83       	st	Z, r19
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	35 e1       	ldi	r19, 0x15	; 21
     5a6:	30 83       	st	Z, r19
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	36 e1       	ldi	r19, 0x16	; 22
     5ac:	30 83       	st	Z, r19
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	37 e1       	ldi	r19, 0x17	; 23
     5b2:	30 83       	st	Z, r19
     5b4:	31 97       	sbiw	r30, 0x01	; 1
     5b6:	38 e1       	ldi	r19, 0x18	; 24
     5b8:	30 83       	st	Z, r19
     5ba:	31 97       	sbiw	r30, 0x01	; 1
     5bc:	39 e1       	ldi	r19, 0x19	; 25
     5be:	30 83       	st	Z, r19
     5c0:	31 97       	sbiw	r30, 0x01	; 1
     5c2:	30 e2       	ldi	r19, 0x20	; 32
     5c4:	30 83       	st	Z, r19
     5c6:	31 97       	sbiw	r30, 0x01	; 1
     5c8:	31 e2       	ldi	r19, 0x21	; 33
     5ca:	30 83       	st	Z, r19
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	20 83       	st	Z, r18
     5d0:	31 97       	sbiw	r30, 0x01	; 1
     5d2:	23 e2       	ldi	r18, 0x23	; 35
     5d4:	20 83       	st	Z, r18
     5d6:	31 97       	sbiw	r30, 0x01	; 1
     5d8:	40 83       	st	Z, r20
     5da:	31 97       	sbiw	r30, 0x01	; 1
     5dc:	50 83       	st	Z, r21
     5de:	31 97       	sbiw	r30, 0x01	; 1
     5e0:	26 e2       	ldi	r18, 0x26	; 38
     5e2:	20 83       	st	Z, r18
     5e4:	31 97       	sbiw	r30, 0x01	; 1
     5e6:	27 e2       	ldi	r18, 0x27	; 39
     5e8:	20 83       	st	Z, r18
     5ea:	31 97       	sbiw	r30, 0x01	; 1
     5ec:	28 e2       	ldi	r18, 0x28	; 40
     5ee:	20 83       	st	Z, r18
     5f0:	31 97       	sbiw	r30, 0x01	; 1
     5f2:	29 e2       	ldi	r18, 0x29	; 41
     5f4:	20 83       	st	Z, r18
     5f6:	31 97       	sbiw	r30, 0x01	; 1
     5f8:	20 e3       	ldi	r18, 0x30	; 48
     5fa:	20 83       	st	Z, r18
     5fc:	31 97       	sbiw	r30, 0x01	; 1
     5fe:	21 e3       	ldi	r18, 0x31	; 49
     600:	20 83       	st	Z, r18
     602:	86 97       	sbiw	r24, 0x26	; 38
     604:	08 95       	ret

00000606 <xPortStartScheduler>:
     606:	1b bc       	out	0x2b, r1	; 43
     608:	8c e7       	ldi	r24, 0x7C	; 124
     60a:	8a bd       	out	0x2a, r24	; 42
     60c:	8b e0       	ldi	r24, 0x0B	; 11
     60e:	8e bd       	out	0x2e, r24	; 46
     610:	89 b7       	in	r24, 0x39	; 57
     612:	80 61       	ori	r24, 0x10	; 16
     614:	89 bf       	out	0x39, r24	; 57
     616:	a0 91 0e 07 	lds	r26, 0x070E	; 0x80070e <pxCurrentTCB>
     61a:	b0 91 0f 07 	lds	r27, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
     61e:	cd 91       	ld	r28, X+
     620:	cd bf       	out	0x3d, r28	; 61
     622:	dd 91       	ld	r29, X+
     624:	de bf       	out	0x3e, r29	; 62
     626:	ff 91       	pop	r31
     628:	ef 91       	pop	r30
     62a:	df 91       	pop	r29
     62c:	cf 91       	pop	r28
     62e:	bf 91       	pop	r27
     630:	af 91       	pop	r26
     632:	9f 91       	pop	r25
     634:	8f 91       	pop	r24
     636:	7f 91       	pop	r23
     638:	6f 91       	pop	r22
     63a:	5f 91       	pop	r21
     63c:	4f 91       	pop	r20
     63e:	3f 91       	pop	r19
     640:	2f 91       	pop	r18
     642:	1f 91       	pop	r17
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	df 90       	pop	r13
     64c:	cf 90       	pop	r12
     64e:	bf 90       	pop	r11
     650:	af 90       	pop	r10
     652:	9f 90       	pop	r9
     654:	8f 90       	pop	r8
     656:	7f 90       	pop	r7
     658:	6f 90       	pop	r6
     65a:	5f 90       	pop	r5
     65c:	4f 90       	pop	r4
     65e:	3f 90       	pop	r3
     660:	2f 90       	pop	r2
     662:	1f 90       	pop	r1
     664:	0f 90       	pop	r0
     666:	0f be       	out	0x3f, r0	; 63
     668:	0f 90       	pop	r0
     66a:	08 95       	ret
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	08 95       	ret

00000670 <vPortYield>:
     670:	0f 92       	push	r0
     672:	0f b6       	in	r0, 0x3f	; 63
     674:	f8 94       	cli
     676:	0f 92       	push	r0
     678:	1f 92       	push	r1
     67a:	11 24       	eor	r1, r1
     67c:	2f 92       	push	r2
     67e:	3f 92       	push	r3
     680:	4f 92       	push	r4
     682:	5f 92       	push	r5
     684:	6f 92       	push	r6
     686:	7f 92       	push	r7
     688:	8f 92       	push	r8
     68a:	9f 92       	push	r9
     68c:	af 92       	push	r10
     68e:	bf 92       	push	r11
     690:	cf 92       	push	r12
     692:	df 92       	push	r13
     694:	ef 92       	push	r14
     696:	ff 92       	push	r15
     698:	0f 93       	push	r16
     69a:	1f 93       	push	r17
     69c:	2f 93       	push	r18
     69e:	3f 93       	push	r19
     6a0:	4f 93       	push	r20
     6a2:	5f 93       	push	r21
     6a4:	6f 93       	push	r22
     6a6:	7f 93       	push	r23
     6a8:	8f 93       	push	r24
     6aa:	9f 93       	push	r25
     6ac:	af 93       	push	r26
     6ae:	bf 93       	push	r27
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
     6b4:	ef 93       	push	r30
     6b6:	ff 93       	push	r31
     6b8:	a0 91 0e 07 	lds	r26, 0x070E	; 0x80070e <pxCurrentTCB>
     6bc:	b0 91 0f 07 	lds	r27, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
     6c0:	0d b6       	in	r0, 0x3d	; 61
     6c2:	0d 92       	st	X+, r0
     6c4:	0e b6       	in	r0, 0x3e	; 62
     6c6:	0d 92       	st	X+, r0
     6c8:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <vTaskSwitchContext>
     6cc:	a0 91 0e 07 	lds	r26, 0x070E	; 0x80070e <pxCurrentTCB>
     6d0:	b0 91 0f 07 	lds	r27, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
     6d4:	cd 91       	ld	r28, X+
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	dd 91       	ld	r29, X+
     6da:	de bf       	out	0x3e, r29	; 62
     6dc:	ff 91       	pop	r31
     6de:	ef 91       	pop	r30
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	bf 91       	pop	r27
     6e6:	af 91       	pop	r26
     6e8:	9f 91       	pop	r25
     6ea:	8f 91       	pop	r24
     6ec:	7f 91       	pop	r23
     6ee:	6f 91       	pop	r22
     6f0:	5f 91       	pop	r21
     6f2:	4f 91       	pop	r20
     6f4:	3f 91       	pop	r19
     6f6:	2f 91       	pop	r18
     6f8:	1f 91       	pop	r17
     6fa:	0f 91       	pop	r16
     6fc:	ff 90       	pop	r15
     6fe:	ef 90       	pop	r14
     700:	df 90       	pop	r13
     702:	cf 90       	pop	r12
     704:	bf 90       	pop	r11
     706:	af 90       	pop	r10
     708:	9f 90       	pop	r9
     70a:	8f 90       	pop	r8
     70c:	7f 90       	pop	r7
     70e:	6f 90       	pop	r6
     710:	5f 90       	pop	r5
     712:	4f 90       	pop	r4
     714:	3f 90       	pop	r3
     716:	2f 90       	pop	r2
     718:	1f 90       	pop	r1
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	0f 90       	pop	r0
     720:	08 95       	ret

00000722 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     722:	1f 92       	push	r1
     724:	0f 92       	push	r0
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	0f 92       	push	r0
     72a:	11 24       	eor	r1, r1
     72c:	2f 93       	push	r18
     72e:	3f 93       	push	r19
     730:	4f 93       	push	r20
     732:	5f 93       	push	r21
     734:	6f 93       	push	r22
     736:	7f 93       	push	r23
     738:	8f 93       	push	r24
     73a:	9f 93       	push	r25
     73c:	af 93       	push	r26
     73e:	bf 93       	push	r27
     740:	ef 93       	push	r30
     742:	ff 93       	push	r31
		vTaskIncrementTick();
     744:	0e 94 75 0b 	call	0x16ea	; 0x16ea <vTaskIncrementTick>
	}
     748:	ff 91       	pop	r31
     74a:	ef 91       	pop	r30
     74c:	bf 91       	pop	r27
     74e:	af 91       	pop	r26
     750:	9f 91       	pop	r25
     752:	8f 91       	pop	r24
     754:	7f 91       	pop	r23
     756:	6f 91       	pop	r22
     758:	5f 91       	pop	r21
     75a:	4f 91       	pop	r20
     75c:	3f 91       	pop	r19
     75e:	2f 91       	pop	r18
     760:	0f 90       	pop	r0
     762:	0f be       	out	0x3f, r0	; 63
     764:	0f 90       	pop	r0
     766:	1f 90       	pop	r1
     768:	18 95       	reti

0000076a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	ec 01       	movw	r28, r24
     770:	8c 8d       	ldd	r24, Y+28	; 0x1c
     772:	88 23       	and	r24, r24
     774:	a9 f1       	breq	.+106    	; 0x7e0 <prvCopyDataToQueue+0x76>
     776:	41 11       	cpse	r20, r1
     778:	17 c0       	rjmp	.+46     	; 0x7a8 <prvCopyDataToQueue+0x3e>
     77a:	48 2f       	mov	r20, r24
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	8c 81       	ldd	r24, Y+4	; 0x04
     780:	9d 81       	ldd	r25, Y+5	; 0x05
     782:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <memcpy>
     786:	2c 8d       	ldd	r18, Y+28	; 0x1c
     788:	8c 81       	ldd	r24, Y+4	; 0x04
     78a:	9d 81       	ldd	r25, Y+5	; 0x05
     78c:	82 0f       	add	r24, r18
     78e:	91 1d       	adc	r25, r1
     790:	9d 83       	std	Y+5, r25	; 0x05
     792:	8c 83       	std	Y+4, r24	; 0x04
     794:	2a 81       	ldd	r18, Y+2	; 0x02
     796:	3b 81       	ldd	r19, Y+3	; 0x03
     798:	82 17       	cp	r24, r18
     79a:	93 07       	cpc	r25, r19
     79c:	08 f1       	brcs	.+66     	; 0x7e0 <prvCopyDataToQueue+0x76>
     79e:	88 81       	ld	r24, Y
     7a0:	99 81       	ldd	r25, Y+1	; 0x01
     7a2:	9d 83       	std	Y+5, r25	; 0x05
     7a4:	8c 83       	std	Y+4, r24	; 0x04
     7a6:	1c c0       	rjmp	.+56     	; 0x7e0 <prvCopyDataToQueue+0x76>
     7a8:	48 2f       	mov	r20, r24
     7aa:	50 e0       	ldi	r21, 0x00	; 0
     7ac:	8e 81       	ldd	r24, Y+6	; 0x06
     7ae:	9f 81       	ldd	r25, Y+7	; 0x07
     7b0:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <memcpy>
     7b4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	91 95       	neg	r25
     7ba:	81 95       	neg	r24
     7bc:	91 09       	sbc	r25, r1
     7be:	2e 81       	ldd	r18, Y+6	; 0x06
     7c0:	3f 81       	ldd	r19, Y+7	; 0x07
     7c2:	28 0f       	add	r18, r24
     7c4:	39 1f       	adc	r19, r25
     7c6:	3f 83       	std	Y+7, r19	; 0x07
     7c8:	2e 83       	std	Y+6, r18	; 0x06
     7ca:	48 81       	ld	r20, Y
     7cc:	59 81       	ldd	r21, Y+1	; 0x01
     7ce:	24 17       	cp	r18, r20
     7d0:	35 07       	cpc	r19, r21
     7d2:	30 f4       	brcc	.+12     	; 0x7e0 <prvCopyDataToQueue+0x76>
     7d4:	2a 81       	ldd	r18, Y+2	; 0x02
     7d6:	3b 81       	ldd	r19, Y+3	; 0x03
     7d8:	82 0f       	add	r24, r18
     7da:	93 1f       	adc	r25, r19
     7dc:	9f 83       	std	Y+7, r25	; 0x07
     7de:	8e 83       	std	Y+6, r24	; 0x06
     7e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7e2:	8f 5f       	subi	r24, 0xFF	; 255
     7e4:	8a 8f       	std	Y+26, r24	; 0x1a
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret

000007ec <prvCopyDataFromQueue>:
     7ec:	fc 01       	movw	r30, r24
     7ee:	80 81       	ld	r24, Z
     7f0:	91 81       	ldd	r25, Z+1	; 0x01
     7f2:	00 97       	sbiw	r24, 0x00	; 0
     7f4:	a1 f0       	breq	.+40     	; 0x81e <prvCopyDataFromQueue+0x32>
     7f6:	44 8d       	ldd	r20, Z+28	; 0x1c
     7f8:	50 e0       	ldi	r21, 0x00	; 0
     7fa:	26 81       	ldd	r18, Z+6	; 0x06
     7fc:	37 81       	ldd	r19, Z+7	; 0x07
     7fe:	24 0f       	add	r18, r20
     800:	35 1f       	adc	r19, r21
     802:	37 83       	std	Z+7, r19	; 0x07
     804:	26 83       	std	Z+6, r18	; 0x06
     806:	a2 81       	ldd	r26, Z+2	; 0x02
     808:	b3 81       	ldd	r27, Z+3	; 0x03
     80a:	2a 17       	cp	r18, r26
     80c:	3b 07       	cpc	r19, r27
     80e:	10 f0       	brcs	.+4      	; 0x814 <prvCopyDataFromQueue+0x28>
     810:	97 83       	std	Z+7, r25	; 0x07
     812:	86 83       	std	Z+6, r24	; 0x06
     814:	cb 01       	movw	r24, r22
     816:	66 81       	ldd	r22, Z+6	; 0x06
     818:	77 81       	ldd	r23, Z+7	; 0x07
     81a:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <memcpy>
     81e:	08 95       	ret

00000820 <prvUnlockQueue>:
     820:	0f 93       	push	r16
     822:	1f 93       	push	r17
     824:	cf 93       	push	r28
     826:	df 93       	push	r29
     828:	ec 01       	movw	r28, r24
     82a:	0f b6       	in	r0, 0x3f	; 63
     82c:	f8 94       	cli
     82e:	0f 92       	push	r0
     830:	8e 8d       	ldd	r24, Y+30	; 0x1e
     832:	18 16       	cp	r1, r24
     834:	b4 f4       	brge	.+44     	; 0x862 <__stack+0x3>
     836:	89 89       	ldd	r24, Y+17	; 0x11
     838:	81 11       	cpse	r24, r1
     83a:	05 c0       	rjmp	.+10     	; 0x846 <prvUnlockQueue+0x26>
     83c:	12 c0       	rjmp	.+36     	; 0x862 <__stack+0x3>
     83e:	89 89       	ldd	r24, Y+17	; 0x11
     840:	81 11       	cpse	r24, r1
     842:	04 c0       	rjmp	.+8      	; 0x84c <prvUnlockQueue+0x2c>
     844:	0e c0       	rjmp	.+28     	; 0x862 <__stack+0x3>
     846:	8e 01       	movw	r16, r28
     848:	0f 5e       	subi	r16, 0xEF	; 239
     84a:	1f 4f       	sbci	r17, 0xFF	; 255
     84c:	c8 01       	movw	r24, r16
     84e:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xTaskRemoveFromEventList>
     852:	81 11       	cpse	r24, r1
     854:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <vTaskMissedYield>
     858:	8e 8d       	ldd	r24, Y+30	; 0x1e
     85a:	81 50       	subi	r24, 0x01	; 1
     85c:	8e 8f       	std	Y+30, r24	; 0x1e
     85e:	18 16       	cp	r1, r24
     860:	74 f3       	brlt	.-36     	; 0x83e <prvUnlockQueue+0x1e>
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	8e 8f       	std	Y+30, r24	; 0x1e
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
     86a:	0f b6       	in	r0, 0x3f	; 63
     86c:	f8 94       	cli
     86e:	0f 92       	push	r0
     870:	8d 8d       	ldd	r24, Y+29	; 0x1d
     872:	18 16       	cp	r1, r24
     874:	b4 f4       	brge	.+44     	; 0x8a2 <__stack+0x43>
     876:	88 85       	ldd	r24, Y+8	; 0x08
     878:	81 11       	cpse	r24, r1
     87a:	05 c0       	rjmp	.+10     	; 0x886 <__stack+0x27>
     87c:	12 c0       	rjmp	.+36     	; 0x8a2 <__stack+0x43>
     87e:	88 85       	ldd	r24, Y+8	; 0x08
     880:	81 11       	cpse	r24, r1
     882:	04 c0       	rjmp	.+8      	; 0x88c <__stack+0x2d>
     884:	0e c0       	rjmp	.+28     	; 0x8a2 <__stack+0x43>
     886:	8e 01       	movw	r16, r28
     888:	08 5f       	subi	r16, 0xF8	; 248
     88a:	1f 4f       	sbci	r17, 0xFF	; 255
     88c:	c8 01       	movw	r24, r16
     88e:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xTaskRemoveFromEventList>
     892:	81 11       	cpse	r24, r1
     894:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <vTaskMissedYield>
     898:	8d 8d       	ldd	r24, Y+29	; 0x1d
     89a:	81 50       	subi	r24, 0x01	; 1
     89c:	8d 8f       	std	Y+29, r24	; 0x1d
     89e:	18 16       	cp	r1, r24
     8a0:	74 f3       	brlt	.-36     	; 0x87e <__stack+0x1f>
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	8d 8f       	std	Y+29, r24	; 0x1d
     8a6:	0f 90       	pop	r0
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	df 91       	pop	r29
     8ac:	cf 91       	pop	r28
     8ae:	1f 91       	pop	r17
     8b0:	0f 91       	pop	r16
     8b2:	08 95       	ret

000008b4 <xQueueCreate>:
     8b4:	cf 92       	push	r12
     8b6:	df 92       	push	r13
     8b8:	ef 92       	push	r14
     8ba:	ff 92       	push	r15
     8bc:	0f 93       	push	r16
     8be:	1f 93       	push	r17
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	88 23       	and	r24, r24
     8c6:	d1 f1       	breq	.+116    	; 0x93c <xQueueCreate+0x88>
     8c8:	e6 2e       	mov	r14, r22
     8ca:	f8 2e       	mov	r15, r24
     8cc:	8f e1       	ldi	r24, 0x1F	; 31
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <pvPortMalloc>
     8d4:	ec 01       	movw	r28, r24
     8d6:	89 2b       	or	r24, r25
     8d8:	99 f1       	breq	.+102    	; 0x940 <xQueueCreate+0x8c>
     8da:	ce 2c       	mov	r12, r14
     8dc:	d1 2c       	mov	r13, r1
     8de:	fc 9c       	mul	r15, r12
     8e0:	80 01       	movw	r16, r0
     8e2:	fd 9c       	mul	r15, r13
     8e4:	10 0d       	add	r17, r0
     8e6:	11 24       	eor	r1, r1
     8e8:	c8 01       	movw	r24, r16
     8ea:	01 96       	adiw	r24, 0x01	; 1
     8ec:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <pvPortMalloc>
     8f0:	99 83       	std	Y+1, r25	; 0x01
     8f2:	88 83       	st	Y, r24
     8f4:	00 97       	sbiw	r24, 0x00	; 0
     8f6:	e1 f0       	breq	.+56     	; 0x930 <xQueueCreate+0x7c>
     8f8:	9c 01       	movw	r18, r24
     8fa:	20 0f       	add	r18, r16
     8fc:	31 1f       	adc	r19, r17
     8fe:	3b 83       	std	Y+3, r19	; 0x03
     900:	2a 83       	std	Y+2, r18	; 0x02
     902:	1a 8e       	std	Y+26, r1	; 0x1a
     904:	9d 83       	std	Y+5, r25	; 0x05
     906:	8c 83       	std	Y+4, r24	; 0x04
     908:	0c 19       	sub	r16, r12
     90a:	1d 09       	sbc	r17, r13
     90c:	08 0f       	add	r16, r24
     90e:	19 1f       	adc	r17, r25
     910:	1f 83       	std	Y+7, r17	; 0x07
     912:	0e 83       	std	Y+6, r16	; 0x06
     914:	fb 8e       	std	Y+27, r15	; 0x1b
     916:	ec 8e       	std	Y+28, r14	; 0x1c
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	8d 8f       	std	Y+29, r24	; 0x1d
     91c:	8e 8f       	std	Y+30, r24	; 0x1e
     91e:	ce 01       	movw	r24, r28
     920:	08 96       	adiw	r24, 0x08	; 8
     922:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
     926:	ce 01       	movw	r24, r28
     928:	41 96       	adiw	r24, 0x11	; 17
     92a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
     92e:	08 c0       	rjmp	.+16     	; 0x940 <xQueueCreate+0x8c>
     930:	ce 01       	movw	r24, r28
     932:	0e 94 06 01 	call	0x20c	; 0x20c <vPortFree>
     936:	c0 e0       	ldi	r28, 0x00	; 0
     938:	d0 e0       	ldi	r29, 0x00	; 0
     93a:	02 c0       	rjmp	.+4      	; 0x940 <xQueueCreate+0x8c>
     93c:	c0 e0       	ldi	r28, 0x00	; 0
     93e:	d0 e0       	ldi	r29, 0x00	; 0
     940:	ce 01       	movw	r24, r28
     942:	df 91       	pop	r29
     944:	cf 91       	pop	r28
     946:	1f 91       	pop	r17
     948:	0f 91       	pop	r16
     94a:	ff 90       	pop	r15
     94c:	ef 90       	pop	r14
     94e:	df 90       	pop	r13
     950:	cf 90       	pop	r12
     952:	08 95       	ret

00000954 <xQueueGenericSend>:
     954:	9f 92       	push	r9
     956:	af 92       	push	r10
     958:	bf 92       	push	r11
     95a:	cf 92       	push	r12
     95c:	df 92       	push	r13
     95e:	ef 92       	push	r14
     960:	ff 92       	push	r15
     962:	0f 93       	push	r16
     964:	1f 93       	push	r17
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	00 d0       	rcall	.+0      	; 0x96c <xQueueGenericSend+0x18>
     96c:	00 d0       	rcall	.+0      	; 0x96e <xQueueGenericSend+0x1a>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	8c 01       	movw	r16, r24
     976:	6b 01       	movw	r12, r22
     978:	5d 83       	std	Y+5, r21	; 0x05
     97a:	4c 83       	std	Y+4, r20	; 0x04
     97c:	92 2e       	mov	r9, r18
     97e:	b1 2c       	mov	r11, r1
     980:	aa 24       	eor	r10, r10
     982:	a3 94       	inc	r10
     984:	7c 01       	movw	r14, r24
     986:	88 e0       	ldi	r24, 0x08	; 8
     988:	e8 0e       	add	r14, r24
     98a:	f1 1c       	adc	r15, r1
     98c:	0f b6       	in	r0, 0x3f	; 63
     98e:	f8 94       	cli
     990:	0f 92       	push	r0
     992:	f8 01       	movw	r30, r16
     994:	92 8d       	ldd	r25, Z+26	; 0x1a
     996:	83 8d       	ldd	r24, Z+27	; 0x1b
     998:	98 17       	cp	r25, r24
     99a:	a8 f4       	brcc	.+42     	; 0x9c6 <xQueueGenericSend+0x72>
     99c:	49 2d       	mov	r20, r9
     99e:	b6 01       	movw	r22, r12
     9a0:	c8 01       	movw	r24, r16
     9a2:	0e 94 b5 03 	call	0x76a	; 0x76a <prvCopyDataToQueue>
     9a6:	f8 01       	movw	r30, r16
     9a8:	81 89       	ldd	r24, Z+17	; 0x11
     9aa:	88 23       	and	r24, r24
     9ac:	41 f0       	breq	.+16     	; 0x9be <xQueueGenericSend+0x6a>
     9ae:	c8 01       	movw	r24, r16
     9b0:	41 96       	adiw	r24, 0x11	; 17
     9b2:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xTaskRemoveFromEventList>
     9b6:	81 30       	cpi	r24, 0x01	; 1
     9b8:	11 f4       	brne	.+4      	; 0x9be <xQueueGenericSend+0x6a>
     9ba:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	50 c0       	rjmp	.+160    	; 0xa66 <xQueueGenericSend+0x112>
     9c6:	8c 81       	ldd	r24, Y+4	; 0x04
     9c8:	9d 81       	ldd	r25, Y+5	; 0x05
     9ca:	89 2b       	or	r24, r25
     9cc:	21 f4       	brne	.+8      	; 0x9d6 <xQueueGenericSend+0x82>
     9ce:	0f 90       	pop	r0
     9d0:	0f be       	out	0x3f, r0	; 63
     9d2:	80 e0       	ldi	r24, 0x00	; 0
     9d4:	48 c0       	rjmp	.+144    	; 0xa66 <xQueueGenericSend+0x112>
     9d6:	b1 10       	cpse	r11, r1
     9d8:	05 c0       	rjmp	.+10     	; 0x9e4 <xQueueGenericSend+0x90>
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskSetTimeOutState>
     9e2:	ba 2c       	mov	r11, r10
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	0f 92       	push	r0
     9f2:	f8 01       	movw	r30, r16
     9f4:	85 8d       	ldd	r24, Z+29	; 0x1d
     9f6:	8f 3f       	cpi	r24, 0xFF	; 255
     9f8:	09 f4       	brne	.+2      	; 0x9fc <xQueueGenericSend+0xa8>
     9fa:	15 8e       	std	Z+29, r1	; 0x1d
     9fc:	f8 01       	movw	r30, r16
     9fe:	86 8d       	ldd	r24, Z+30	; 0x1e
     a00:	8f 3f       	cpi	r24, 0xFF	; 255
     a02:	09 f4       	brne	.+2      	; 0xa06 <xQueueGenericSend+0xb2>
     a04:	16 8e       	std	Z+30, r1	; 0x1e
     a06:	0f 90       	pop	r0
     a08:	0f be       	out	0x3f, r0	; 63
     a0a:	be 01       	movw	r22, r28
     a0c:	6c 5f       	subi	r22, 0xFC	; 252
     a0e:	7f 4f       	sbci	r23, 0xFF	; 255
     a10:	ce 01       	movw	r24, r28
     a12:	01 96       	adiw	r24, 0x01	; 1
     a14:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <xTaskCheckForTimeOut>
     a18:	81 11       	cpse	r24, r1
     a1a:	1f c0       	rjmp	.+62     	; 0xa5a <xQueueGenericSend+0x106>
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	0f 92       	push	r0
     a22:	f8 01       	movw	r30, r16
     a24:	92 8d       	ldd	r25, Z+26	; 0x1a
     a26:	0f 90       	pop	r0
     a28:	0f be       	out	0x3f, r0	; 63
     a2a:	83 8d       	ldd	r24, Z+27	; 0x1b
     a2c:	98 13       	cpse	r25, r24
     a2e:	0f c0       	rjmp	.+30     	; 0xa4e <xQueueGenericSend+0xfa>
     a30:	6c 81       	ldd	r22, Y+4	; 0x04
     a32:	7d 81       	ldd	r23, Y+5	; 0x05
     a34:	c7 01       	movw	r24, r14
     a36:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vTaskPlaceOnEventList>
     a3a:	c8 01       	movw	r24, r16
     a3c:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
     a40:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
     a44:	81 11       	cpse	r24, r1
     a46:	a2 cf       	rjmp	.-188    	; 0x98c <xQueueGenericSend+0x38>
     a48:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
     a4c:	9f cf       	rjmp	.-194    	; 0x98c <xQueueGenericSend+0x38>
     a4e:	c8 01       	movw	r24, r16
     a50:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
     a54:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
     a58:	99 cf       	rjmp	.-206    	; 0x98c <xQueueGenericSend+0x38>
     a5a:	c8 01       	movw	r24, r16
     a5c:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
     a60:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
     a64:	80 e0       	ldi	r24, 0x00	; 0
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	0f 90       	pop	r0
     a6e:	0f 90       	pop	r0
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	ff 90       	pop	r15
     a7a:	ef 90       	pop	r14
     a7c:	df 90       	pop	r13
     a7e:	cf 90       	pop	r12
     a80:	bf 90       	pop	r11
     a82:	af 90       	pop	r10
     a84:	9f 90       	pop	r9
     a86:	08 95       	ret

00000a88 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     a88:	9f 92       	push	r9
     a8a:	af 92       	push	r10
     a8c:	bf 92       	push	r11
     a8e:	cf 92       	push	r12
     a90:	df 92       	push	r13
     a92:	ef 92       	push	r14
     a94:	ff 92       	push	r15
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	00 d0       	rcall	.+0      	; 0xaa0 <xQueueGenericReceive+0x18>
     aa0:	00 d0       	rcall	.+0      	; 0xaa2 <xQueueGenericReceive+0x1a>
     aa2:	1f 92       	push	r1
     aa4:	cd b7       	in	r28, 0x3d	; 61
     aa6:	de b7       	in	r29, 0x3e	; 62
     aa8:	8c 01       	movw	r16, r24
     aaa:	6b 01       	movw	r12, r22
     aac:	5d 83       	std	Y+5, r21	; 0x05
     aae:	4c 83       	std	Y+4, r20	; 0x04
     ab0:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     ab2:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     ab4:	aa 24       	eor	r10, r10
     ab6:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ab8:	7c 01       	movw	r14, r24
     aba:	81 e1       	ldi	r24, 0x11	; 17
     abc:	e8 0e       	add	r14, r24
     abe:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ac0:	0f b6       	in	r0, 0x3f	; 63
     ac2:	f8 94       	cli
     ac4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ac6:	f8 01       	movw	r30, r16
     ac8:	82 8d       	ldd	r24, Z+26	; 0x1a
     aca:	88 23       	and	r24, r24
     acc:	49 f1       	breq	.+82     	; 0xb20 <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     ace:	e6 80       	ldd	r14, Z+6	; 0x06
     ad0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ad2:	b6 01       	movw	r22, r12
     ad4:	c8 01       	movw	r24, r16
     ad6:	0e 94 f6 03 	call	0x7ec	; 0x7ec <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ada:	91 10       	cpse	r9, r1
     adc:	10 c0       	rjmp	.+32     	; 0xafe <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     ade:	f8 01       	movw	r30, r16
     ae0:	82 8d       	ldd	r24, Z+26	; 0x1a
     ae2:	81 50       	subi	r24, 0x01	; 1
     ae4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ae6:	80 85       	ldd	r24, Z+8	; 0x08
     ae8:	88 23       	and	r24, r24
     aea:	b1 f0       	breq	.+44     	; 0xb18 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     aec:	c8 01       	movw	r24, r16
     aee:	08 96       	adiw	r24, 0x08	; 8
     af0:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xTaskRemoveFromEventList>
     af4:	81 30       	cpi	r24, 0x01	; 1
     af6:	81 f4       	brne	.+32     	; 0xb18 <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     af8:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
     afc:	0d c0       	rjmp	.+26     	; 0xb18 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     afe:	f8 01       	movw	r30, r16
     b00:	f7 82       	std	Z+7, r15	; 0x07
     b02:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b04:	81 89       	ldd	r24, Z+17	; 0x11
     b06:	88 23       	and	r24, r24
     b08:	39 f0       	breq	.+14     	; 0xb18 <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b0a:	c8 01       	movw	r24, r16
     b0c:	41 96       	adiw	r24, 0x11	; 17
     b0e:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xTaskRemoveFromEventList>
     b12:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     b14:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     b18:	0f 90       	pop	r0
     b1a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b1c:	81 e0       	ldi	r24, 0x01	; 1
     b1e:	4f c0       	rjmp	.+158    	; 0xbbe <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     b20:	8c 81       	ldd	r24, Y+4	; 0x04
     b22:	9d 81       	ldd	r25, Y+5	; 0x05
     b24:	89 2b       	or	r24, r25
     b26:	21 f4       	brne	.+8      	; 0xb30 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b28:	0f 90       	pop	r0
     b2a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	47 c0       	rjmp	.+142    	; 0xbbe <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     b30:	b1 10       	cpse	r11, r1
     b32:	05 c0       	rjmp	.+10     	; 0xb3e <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b34:	ce 01       	movw	r24, r28
     b36:	01 96       	adiw	r24, 0x01	; 1
     b38:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b3c:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b42:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	f8 94       	cli
     b4a:	0f 92       	push	r0
     b4c:	f8 01       	movw	r30, r16
     b4e:	85 8d       	ldd	r24, Z+29	; 0x1d
     b50:	8f 3f       	cpi	r24, 0xFF	; 255
     b52:	09 f4       	brne	.+2      	; 0xb56 <xQueueGenericReceive+0xce>
     b54:	15 8e       	std	Z+29, r1	; 0x1d
     b56:	f8 01       	movw	r30, r16
     b58:	86 8d       	ldd	r24, Z+30	; 0x1e
     b5a:	8f 3f       	cpi	r24, 0xFF	; 255
     b5c:	09 f4       	brne	.+2      	; 0xb60 <xQueueGenericReceive+0xd8>
     b5e:	16 8e       	std	Z+30, r1	; 0x1e
     b60:	0f 90       	pop	r0
     b62:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b64:	be 01       	movw	r22, r28
     b66:	6c 5f       	subi	r22, 0xFC	; 252
     b68:	7f 4f       	sbci	r23, 0xFF	; 255
     b6a:	ce 01       	movw	r24, r28
     b6c:	01 96       	adiw	r24, 0x01	; 1
     b6e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <xTaskCheckForTimeOut>
     b72:	81 11       	cpse	r24, r1
     b74:	1e c0       	rjmp	.+60     	; 0xbb2 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     b7c:	f8 01       	movw	r30, r16
     b7e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     b80:	0f 90       	pop	r0
     b82:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b84:	81 11       	cpse	r24, r1
     b86:	0f c0       	rjmp	.+30     	; 0xba6 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b88:	6c 81       	ldd	r22, Y+4	; 0x04
     b8a:	7d 81       	ldd	r23, Y+5	; 0x05
     b8c:	c7 01       	movw	r24, r14
     b8e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b92:	c8 01       	movw	r24, r16
     b94:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b98:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
     b9c:	81 11       	cpse	r24, r1
     b9e:	90 cf       	rjmp	.-224    	; 0xac0 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     ba0:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
     ba4:	8d cf       	rjmp	.-230    	; 0xac0 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     ba6:	c8 01       	movw	r24, r16
     ba8:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     bac:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
     bb0:	87 cf       	rjmp	.-242    	; 0xac0 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     bb2:	c8 01       	movw	r24, r16
     bb4:	0e 94 10 04 	call	0x820	; 0x820 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bb8:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     bbc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     bbe:	0f 90       	pop	r0
     bc0:	0f 90       	pop	r0
     bc2:	0f 90       	pop	r0
     bc4:	0f 90       	pop	r0
     bc6:	0f 90       	pop	r0
     bc8:	df 91       	pop	r29
     bca:	cf 91       	pop	r28
     bcc:	1f 91       	pop	r17
     bce:	0f 91       	pop	r16
     bd0:	ff 90       	pop	r15
     bd2:	ef 90       	pop	r14
     bd4:	df 90       	pop	r13
     bd6:	cf 90       	pop	r12
     bd8:	bf 90       	pop	r11
     bda:	af 90       	pop	r10
     bdc:	9f 90       	pop	r9
     bde:	08 95       	ret

00000be0 <welcome>:
			lcd_disp_string_xy(" " , 0 , i-1);
			lcd_disp_string_xy("Welcome" , 0 , i);
			vTaskDelay(500/13);
		}
		lcd_clrScreen();
		for (int i =9 ; i>0 ; i--)
     be0:	0f 2e       	mov	r0, r31
     be2:	f3 e0       	ldi	r31, 0x03	; 3
     be4:	ef 2e       	mov	r14, r31
     be6:	f1 2c       	mov	r15, r1
     be8:	f0 2d       	mov	r31, r0
     bea:	3e c0       	rjmp	.+124    	; 0xc68 <welcome+0x88>
     bec:	21 96       	adiw	r28, 0x01	; 1
     bee:	0f 5f       	subi	r16, 0xFF	; 255
     bf0:	1f 4f       	sbci	r17, 0xFF	; 255
	int count = 0;
	for(int j=0;j<3;j++)
	{
		for (int i =0 ; i<8 ; i++)
		{
			if(i!=0)
     bf2:	20 97       	sbiw	r28, 0x00	; 0
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <welcome+0x18>
     bf6:	6b c0       	rjmp	.+214    	; 0xcce <welcome+0xee>
			lcd_disp_string_xy(" " , 0 , i-1);
     bf8:	ae 01       	movw	r20, r28
     bfa:	41 50       	subi	r20, 0x01	; 1
     bfc:	51 09       	sbc	r21, r1
     bfe:	60 e0       	ldi	r22, 0x00	; 0
     c00:	70 e0       	ldi	r23, 0x00	; 0
     c02:	84 e6       	ldi	r24, 0x64	; 100
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
			lcd_disp_string_xy("Welcome" , 0 , i);
     c0a:	ae 01       	movw	r20, r28
     c0c:	60 e0       	ldi	r22, 0x00	; 0
     c0e:	70 e0       	ldi	r23, 0x00	; 0
     c10:	86 e6       	ldi	r24, 0x66	; 102
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
			vTaskDelay(500/13);
     c18:	86 e2       	ldi	r24, 0x26	; 38
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
void welcome (void *p)
{
	int count = 0;
	for(int j=0;j<3;j++)
	{
		for (int i =0 ; i<8 ; i++)
     c20:	08 30       	cpi	r16, 0x08	; 8
     c22:	11 05       	cpc	r17, r1
     c24:	1c f3       	brlt	.-58     	; 0xbec <welcome+0xc>
			if(i!=0)
			lcd_disp_string_xy(" " , 0 , i-1);
			lcd_disp_string_xy("Welcome" , 0 , i);
			vTaskDelay(500/13);
		}
		lcd_clrScreen();
     c26:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
		for (int i =9 ; i>0 ; i--)
     c2a:	c9 e0       	ldi	r28, 0x09	; 9
     c2c:	d0 e0       	ldi	r29, 0x00	; 0
		{
			lcd_disp_string_xy(" " , 0 , i+7);
     c2e:	ae 01       	movw	r20, r28
     c30:	49 5f       	subi	r20, 0xF9	; 249
     c32:	5f 4f       	sbci	r21, 0xFF	; 255
     c34:	60 e0       	ldi	r22, 0x00	; 0
     c36:	70 e0       	ldi	r23, 0x00	; 0
     c38:	84 e6       	ldi	r24, 0x64	; 100
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
			lcd_disp_string_xy("Welcome" , 0 , i);
     c40:	ae 01       	movw	r20, r28
     c42:	60 e0       	ldi	r22, 0x00	; 0
     c44:	70 e0       	ldi	r23, 0x00	; 0
     c46:	86 e6       	ldi	r24, 0x66	; 102
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
			vTaskDelay(500/13);
     c4e:	86 e2       	ldi	r24, 0x26	; 38
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
			lcd_disp_string_xy(" " , 0 , i-1);
			lcd_disp_string_xy("Welcome" , 0 , i);
			vTaskDelay(500/13);
		}
		lcd_clrScreen();
		for (int i =9 ; i>0 ; i--)
     c56:	21 97       	sbiw	r28, 0x01	; 1
     c58:	51 f7       	brne	.-44     	; 0xc2e <welcome+0x4e>
		{
			lcd_disp_string_xy(" " , 0 , i+7);
			lcd_disp_string_xy("Welcome" , 0 , i);
			vTaskDelay(500/13);
		}
		lcd_clrScreen();
     c5a:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	e8 1a       	sub	r14, r24
     c62:	f1 08       	sbc	r15, r1
	return 0;
}
void welcome (void *p)
{
	int count = 0;
	for(int j=0;j<3;j++)
     c64:	09 f4       	brne	.+2      	; 0xc68 <welcome+0x88>
     c66:	40 c0       	rjmp	.+128    	; 0xce8 <welcome+0x108>
	vTaskStartScheduler();

	return 0;
}
void welcome (void *p)
{
     c68:	01 e0       	ldi	r16, 0x01	; 1
     c6a:	10 e0       	ldi	r17, 0x00	; 0
     c6c:	c0 e0       	ldi	r28, 0x00	; 0
     c6e:	d0 e0       	ldi	r29, 0x00	; 0
     c70:	c0 cf       	rjmp	.-128    	; 0xbf2 <welcome+0x12>
		lcd_clrScreen();
	}
	
	for(;;)
	{
		lcd_disp_string_xy("press any key to" , 0 , 0);
     c72:	40 e0       	ldi	r20, 0x00	; 0
     c74:	50 e0       	ldi	r21, 0x00	; 0
     c76:	60 e0       	ldi	r22, 0x00	; 0
     c78:	70 e0       	ldi	r23, 0x00	; 0
     c7a:	8e e6       	ldi	r24, 0x6E	; 110
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
		lcd_disp_string_xy("continue" , 1 , 0);
     c82:	40 e0       	ldi	r20, 0x00	; 0
     c84:	50 e0       	ldi	r21, 0x00	; 0
     c86:	61 e0       	ldi	r22, 0x01	; 1
     c88:	70 e0       	ldi	r23, 0x00	; 0
     c8a:	8f e7       	ldi	r24, 0x7F	; 127
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
		vTaskDelay(500);
     c92:	84 ef       	ldi	r24, 0xF4	; 244
     c94:	91 e0       	ldi	r25, 0x01	; 1
     c96:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
		lcd_clrScreen();
     c9a:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
		vTaskDelay(250);
     c9e:	8a ef       	ldi	r24, 0xFA	; 250
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
			count++;
     ca6:	21 96       	adiw	r28, 0x01	; 1
		
		if (count == 13)
     ca8:	cd 30       	cpi	r28, 0x0D	; 13
     caa:	d1 05       	cpc	r29, r1
     cac:	11 f7       	brne	.-60     	; 0xc72 <welcome+0x92>
		{
			xSemaphoreGive(led_start);
     cae:	20 e0       	ldi	r18, 0x00	; 0
     cb0:	40 e0       	ldi	r20, 0x00	; 0
     cb2:	50 e0       	ldi	r21, 0x00	; 0
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	70 e0       	ldi	r23, 0x00	; 0
     cb8:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <led_start>
     cbc:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <led_start+0x1>
     cc0:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
			vTaskDelete(NULL);
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <vTaskDelete>
     ccc:	d2 cf       	rjmp	.-92     	; 0xc72 <welcome+0x92>
	{
		for (int i =0 ; i<8 ; i++)
		{
			if(i!=0)
			lcd_disp_string_xy(" " , 0 , i-1);
			lcd_disp_string_xy("Welcome" , 0 , i);
     cce:	40 e0       	ldi	r20, 0x00	; 0
     cd0:	50 e0       	ldi	r21, 0x00	; 0
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	70 e0       	ldi	r23, 0x00	; 0
     cd6:	86 e6       	ldi	r24, 0x66	; 102
     cd8:	90 e0       	ldi	r25, 0x00	; 0
     cda:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
			vTaskDelay(500/13);
     cde:	86 e2       	ldi	r24, 0x26	; 38
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
     ce6:	82 cf       	rjmp	.-252    	; 0xbec <welcome+0xc>
		lcd_clrScreen();
	}
	
	for(;;)
	{
		lcd_disp_string_xy("press any key to" , 0 , 0);
     ce8:	40 e0       	ldi	r20, 0x00	; 0
     cea:	50 e0       	ldi	r21, 0x00	; 0
     cec:	60 e0       	ldi	r22, 0x00	; 0
     cee:	70 e0       	ldi	r23, 0x00	; 0
     cf0:	8e e6       	ldi	r24, 0x6E	; 110
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
		lcd_disp_string_xy("continue" , 1 , 0);
     cf8:	40 e0       	ldi	r20, 0x00	; 0
     cfa:	50 e0       	ldi	r21, 0x00	; 0
     cfc:	61 e0       	ldi	r22, 0x01	; 1
     cfe:	70 e0       	ldi	r23, 0x00	; 0
     d00:	8f e7       	ldi	r24, 0x7F	; 127
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
		vTaskDelay(500);
     d08:	84 ef       	ldi	r24, 0xF4	; 244
     d0a:	91 e0       	ldi	r25, 0x01	; 1
     d0c:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
		lcd_clrScreen();
     d10:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
		vTaskDelay(250);
     d14:	8a ef       	ldi	r24, 0xFA	; 250
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
			count++;
     d1c:	c1 e0       	ldi	r28, 0x01	; 1
     d1e:	d0 e0       	ldi	r29, 0x00	; 0
     d20:	a8 cf       	rjmp	.-176    	; 0xc72 <welcome+0x92>

00000d22 <get_button>:
		}
	}
	vTaskDelete(NULL);
}
void get_button (void *p)
{
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	00 d0       	rcall	.+0      	; 0xd28 <get_button+0x6>
     d28:	cd b7       	in	r28, 0x3d	; 61
     d2a:	de b7       	in	r29, 0x3e	; 62
	unsigned char current_button = 255;
	portTickType wait = xTaskGetTickCount();
     d2c:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
     d30:	9a 83       	std	Y+2, r25	; 0x02
     d32:	89 83       	std	Y+1, r24	; 0x01
	vTaskDelay(3000);
     d34:	88 eb       	ldi	r24, 0xB8	; 184
     d36:	9b e0       	ldi	r25, 0x0B	; 11
     d38:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
	}
	vTaskDelete(NULL);
}
void get_button (void *p)
{
	unsigned char current_button = 255;
     d3c:	1f ef       	ldi	r17, 0xFF	; 255
			if(current_button != pressed_button)
			{
				if(start_button == 0)
				{
					vTaskDelete(welcome_h);
					start_button = 1;
     d3e:	01 e0       	ldi	r16, 0x01	; 1
     d40:	03 c0       	rjmp	.+6      	; 0xd48 <get_button+0x26>
				}
				current_button = pressed_button;
			}
		}
		if (pressed_button == 255)
		current_button = 255;
     d42:	18 2f       	mov	r17, r24
     d44:	01 c0       	rjmp	.+2      	; 0xd48 <get_button+0x26>
     d46:	18 2f       	mov	r17, r24
	unsigned char current_button = 255;
	portTickType wait = xTaskGetTickCount();
	vTaskDelay(3000);
	while (1)
	{
		vTaskDelayUntil (&wait , 10);
     d48:	6a e0       	ldi	r22, 0x0A	; 10
     d4a:	70 e0       	ldi	r23, 0x00	; 0
     d4c:	ce 01       	movw	r24, r28
     d4e:	01 96       	adiw	r24, 0x01	; 1
     d50:	0e 94 be 0c 	call	0x197c	; 0x197c <vTaskDelayUntil>
		pressed_button = KeyPad_u8GetPressedKey();
     d54:	0e 94 33 01 	call	0x266	; 0x266 <KeyPad_u8GetPressedKey>
     d58:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <pressed_button>
		if (pressed_button != 255)
     d5c:	8f 3f       	cpi	r24, 0xFF	; 255
     d5e:	89 f3       	breq	.-30     	; 0xd42 <get_button+0x20>
		{
			if(current_button != pressed_button)
     d60:	18 17       	cp	r17, r24
     d62:	89 f3       	breq	.-30     	; 0xd46 <get_button+0x24>
			{
				if(start_button == 0)
     d64:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <start_button>
     d68:	81 11       	cpse	r24, r1
     d6a:	14 c0       	rjmp	.+40     	; 0xd94 <get_button+0x72>
				{
					vTaskDelete(welcome_h);
     d6c:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <welcome_h>
     d70:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <welcome_h+0x1>
     d74:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <vTaskDelete>
					start_button = 1;
     d78:	00 93 ac 06 	sts	0x06AC, r16	; 0x8006ac <start_button>
					xSemaphoreGive(calc_start);
     d7c:	20 e0       	ldi	r18, 0x00	; 0
     d7e:	40 e0       	ldi	r20, 0x00	; 0
     d80:	50 e0       	ldi	r21, 0x00	; 0
     d82:	60 e0       	ldi	r22, 0x00	; 0
     d84:	70 e0       	ldi	r23, 0x00	; 0
     d86:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <calc_start>
     d8a:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <calc_start+0x1>
     d8e:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
     d92:	0b c0       	rjmp	.+22     	; 0xdaa <get_button+0x88>
				}
				else
				{
					xSemaphoreGive(button_data);
     d94:	20 e0       	ldi	r18, 0x00	; 0
     d96:	40 e0       	ldi	r20, 0x00	; 0
     d98:	50 e0       	ldi	r21, 0x00	; 0
     d9a:	60 e0       	ldi	r22, 0x00	; 0
     d9c:	70 e0       	ldi	r23, 0x00	; 0
     d9e:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <button_data>
     da2:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <button_data+0x1>
     da6:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
				}
				current_button = pressed_button;
     daa:	10 91 61 00 	lds	r17, 0x0061	; 0x800061 <pressed_button>
     dae:	cc cf       	rjmp	.-104    	; 0xd48 <get_button+0x26>

00000db0 <reset_button>:

TCCR2 = 0x00;
	lcd_clrScreen();
}
void reset_button (void *p)
{
     db0:	cf 93       	push	r28
     db2:	df 93       	push	r29
     db4:	00 d0       	rcall	.+0      	; 0xdb6 <reset_button+0x6>
     db6:	cd b7       	in	r28, 0x3d	; 61
     db8:	de b7       	in	r29, 0x3e	; 62
	portTickType wait = xTaskGetTickCount();
     dba:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
     dbe:	9a 83       	std	Y+2, r25	; 0x02
     dc0:	89 83       	std	Y+1, r24	; 0x01
	static unsigned char counter = 0; 
	vTaskDelay(3000);
     dc2:	88 eb       	ldi	r24, 0xB8	; 184
     dc4:	9b e0       	ldi	r25, 0x0B	; 11
     dc6:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
	while (1)
	{
		vTaskDelayUntil(&wait , 100);
     dca:	64 e6       	ldi	r22, 0x64	; 100
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	ce 01       	movw	r24, r28
     dd0:	01 96       	adiw	r24, 0x01	; 1
     dd2:	0e 94 be 0c 	call	0x197c	; 0x197c <vTaskDelayUntil>
		if (DIO_u8GetPin(PUSH_BUTTON) == DIO_HIGH)
     dd6:	8d e1       	ldi	r24, 0x1D	; 29
     dd8:	0e 94 79 00 	call	0xf2	; 0xf2 <DIO_u8GetPin>
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	29 f4       	brne	.+10     	; 0xdea <reset_button+0x3a>
		{
			counter++;
     de0:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <counter.2306>
     de4:	8f 5f       	subi	r24, 0xFF	; 255
     de6:	80 93 82 06 	sts	0x0682, r24	; 0x800682 <counter.2306>
		}
		if(counter == 30)
     dea:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <counter.2306>
     dee:	8e 31       	cpi	r24, 0x1E	; 30
     df0:	61 f7       	brne	.-40     	; 0xdca <reset_button+0x1a>
		{
			xSemaphoreGive(led_start);
     df2:	20 e0       	ldi	r18, 0x00	; 0
     df4:	40 e0       	ldi	r20, 0x00	; 0
     df6:	50 e0       	ldi	r21, 0x00	; 0
     df8:	60 e0       	ldi	r22, 0x00	; 0
     dfa:	70 e0       	ldi	r23, 0x00	; 0
     dfc:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <led_start>
     e00:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <led_start+0x1>
     e04:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
			break;
		}
	}
	vTaskDelete(NULL);
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <vTaskDelete>
     e10:	0f 90       	pop	r0
     e12:	0f 90       	pop	r0
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	08 95       	ret

00000e1a <main>:
unsigned char start_button = 0;
unsigned char pressed_button = 255;

#define PUSH_BUTTON 29
int main ()
{
     e1a:	af 92       	push	r10
     e1c:	bf 92       	push	r11
     e1e:	cf 92       	push	r12
     e20:	df 92       	push	r13
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	cd b7       	in	r28, 0x3d	; 61
     e2e:	de b7       	in	r29, 0x3e	; 62
     e30:	28 97       	sbiw	r28, 0x08	; 8
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	de bf       	out	0x3e, r29	; 62
     e38:	0f be       	out	0x3f, r0	; 63
     e3a:	cd bf       	out	0x3d, r28	; 61
	xTaskHandle get_button_h;
	xTaskHandle calc_h;
	xTaskHandle led_h;
	xTaskHandle reset_h;

	xTaskCreate(welcome,NULL,150,NULL,4,&welcome_h);
     e3c:	a1 2c       	mov	r10, r1
     e3e:	b1 2c       	mov	r11, r1
     e40:	c1 2c       	mov	r12, r1
     e42:	d1 2c       	mov	r13, r1
     e44:	0f 2e       	mov	r0, r31
     e46:	f4 e1       	ldi	r31, 0x14	; 20
     e48:	ef 2e       	mov	r14, r31
     e4a:	f7 e0       	ldi	r31, 0x07	; 7
     e4c:	ff 2e       	mov	r15, r31
     e4e:	f0 2d       	mov	r31, r0
     e50:	04 e0       	ldi	r16, 0x04	; 4
     e52:	20 e0       	ldi	r18, 0x00	; 0
     e54:	30 e0       	ldi	r19, 0x00	; 0
     e56:	46 e9       	ldi	r20, 0x96	; 150
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	60 e0       	ldi	r22, 0x00	; 0
     e5c:	70 e0       	ldi	r23, 0x00	; 0
     e5e:	80 ef       	ldi	r24, 0xF0	; 240
     e60:	95 e0       	ldi	r25, 0x05	; 5
     e62:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
	xTaskCreate(get_button,NULL,150,NULL,3,&get_button_h);
     e66:	ce 01       	movw	r24, r28
     e68:	01 96       	adiw	r24, 0x01	; 1
     e6a:	7c 01       	movw	r14, r24
     e6c:	03 e0       	ldi	r16, 0x03	; 3
     e6e:	20 e0       	ldi	r18, 0x00	; 0
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	46 e9       	ldi	r20, 0x96	; 150
     e74:	50 e0       	ldi	r21, 0x00	; 0
     e76:	60 e0       	ldi	r22, 0x00	; 0
     e78:	70 e0       	ldi	r23, 0x00	; 0
     e7a:	81 e9       	ldi	r24, 0x91	; 145
     e7c:	96 e0       	ldi	r25, 0x06	; 6
     e7e:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
	xTaskCreate(calc,NULL,150,NULL,2,&calc_h);
     e82:	ce 01       	movw	r24, r28
     e84:	03 96       	adiw	r24, 0x03	; 3
     e86:	7c 01       	movw	r14, r24
     e88:	02 e0       	ldi	r16, 0x02	; 2
     e8a:	20 e0       	ldi	r18, 0x00	; 0
     e8c:	30 e0       	ldi	r19, 0x00	; 0
     e8e:	46 e9       	ldi	r20, 0x96	; 150
     e90:	50 e0       	ldi	r21, 0x00	; 0
     e92:	60 e0       	ldi	r22, 0x00	; 0
     e94:	70 e0       	ldi	r23, 0x00	; 0
     e96:	87 e2       	ldi	r24, 0x27	; 39
     e98:	99 e0       	ldi	r25, 0x09	; 9
     e9a:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
	xTaskCreate(led,NULL,100,NULL,2,&led_h);
     e9e:	ce 01       	movw	r24, r28
     ea0:	05 96       	adiw	r24, 0x05	; 5
     ea2:	7c 01       	movw	r14, r24
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	30 e0       	ldi	r19, 0x00	; 0
     ea8:	44 e6       	ldi	r20, 0x64	; 100
     eaa:	50 e0       	ldi	r21, 0x00	; 0
     eac:	60 e0       	ldi	r22, 0x00	; 0
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	8f e7       	ldi	r24, 0x7F	; 127
     eb2:	99 e0       	ldi	r25, 0x09	; 9
     eb4:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
	xTaskCreate(reset_button,NULL,100,NULL,2,&reset_h);
     eb8:	ce 01       	movw	r24, r28
     eba:	07 96       	adiw	r24, 0x07	; 7
     ebc:	7c 01       	movw	r14, r24
     ebe:	20 e0       	ldi	r18, 0x00	; 0
     ec0:	30 e0       	ldi	r19, 0x00	; 0
     ec2:	44 e6       	ldi	r20, 0x64	; 100
     ec4:	50 e0       	ldi	r21, 0x00	; 0
     ec6:	60 e0       	ldi	r22, 0x00	; 0
     ec8:	70 e0       	ldi	r23, 0x00	; 0
     eca:	88 ed       	ldi	r24, 0xD8	; 216
     ecc:	96 e0       	ldi	r25, 0x06	; 6
     ece:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
	
	vSemaphoreCreateBinary(calc_start);
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	81 e0       	ldi	r24, 0x01	; 1
     ed6:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <xQueueCreate>
     eda:	90 93 13 07 	sts	0x0713, r25	; 0x800713 <calc_start+0x1>
     ede:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <calc_start>
     ee2:	00 97       	sbiw	r24, 0x00	; 0
     ee4:	39 f0       	breq	.+14     	; 0xef4 <main+0xda>
     ee6:	20 e0       	ldi	r18, 0x00	; 0
     ee8:	40 e0       	ldi	r20, 0x00	; 0
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	60 e0       	ldi	r22, 0x00	; 0
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
	xSemaphoreTake(calc_start,portMAX_DELAY);
     ef4:	20 e0       	ldi	r18, 0x00	; 0
     ef6:	4f ef       	ldi	r20, 0xFF	; 255
     ef8:	5f ef       	ldi	r21, 0xFF	; 255
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	70 e0       	ldi	r23, 0x00	; 0
     efe:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <calc_start>
     f02:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <calc_start+0x1>
     f06:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
	vSemaphoreCreateBinary(led_start);
     f0a:	60 e0       	ldi	r22, 0x00	; 0
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <xQueueCreate>
     f12:	90 93 17 07 	sts	0x0717, r25	; 0x800717 <led_start+0x1>
     f16:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <led_start>
     f1a:	00 97       	sbiw	r24, 0x00	; 0
     f1c:	39 f0       	breq	.+14     	; 0xf2c <main+0x112>
     f1e:	20 e0       	ldi	r18, 0x00	; 0
     f20:	40 e0       	ldi	r20, 0x00	; 0
     f22:	50 e0       	ldi	r21, 0x00	; 0
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	70 e0       	ldi	r23, 0x00	; 0
     f28:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
	xSemaphoreTake(led_start,portMAX_DELAY);
     f2c:	20 e0       	ldi	r18, 0x00	; 0
     f2e:	4f ef       	ldi	r20, 0xFF	; 255
     f30:	5f ef       	ldi	r21, 0xFF	; 255
     f32:	60 e0       	ldi	r22, 0x00	; 0
     f34:	70 e0       	ldi	r23, 0x00	; 0
     f36:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <led_start>
     f3a:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <led_start+0x1>
     f3e:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
	vSemaphoreCreateBinary(button_data);
     f42:	60 e0       	ldi	r22, 0x00	; 0
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <xQueueCreate>
     f4a:	90 93 11 07 	sts	0x0711, r25	; 0x800711 <button_data+0x1>
     f4e:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <button_data>
     f52:	00 97       	sbiw	r24, 0x00	; 0
     f54:	39 f0       	breq	.+14     	; 0xf64 <main+0x14a>
     f56:	20 e0       	ldi	r18, 0x00	; 0
     f58:	40 e0       	ldi	r20, 0x00	; 0
     f5a:	50 e0       	ldi	r21, 0x00	; 0
     f5c:	60 e0       	ldi	r22, 0x00	; 0
     f5e:	70 e0       	ldi	r23, 0x00	; 0
     f60:	0e 94 aa 04 	call	0x954	; 0x954 <xQueueGenericSend>
	xSemaphoreTake(button_data,portMAX_DELAY);
     f64:	20 e0       	ldi	r18, 0x00	; 0
     f66:	4f ef       	ldi	r20, 0xFF	; 255
     f68:	5f ef       	ldi	r21, 0xFF	; 255
     f6a:	60 e0       	ldi	r22, 0x00	; 0
     f6c:	70 e0       	ldi	r23, 0x00	; 0
     f6e:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <button_data>
     f72:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <button_data+0x1>
     f76:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>

	DDRD |= (1<<7);
     f7a:	8f 9a       	sbi	0x11, 7	; 17
	DDRD &= ~(1<<5);
     f7c:	8d 98       	cbi	0x11, 5	; 17
	lcd_init();
     f7e:	0e 94 9a 01 	call	0x334	; 0x334 <lcd_init>
	vTaskStartScheduler();
     f82:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskStartScheduler>

	return 0;
}
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	90 e0       	ldi	r25, 0x00	; 0
     f8a:	28 96       	adiw	r28, 0x08	; 8
     f8c:	0f b6       	in	r0, 0x3f	; 63
     f8e:	f8 94       	cli
     f90:	de bf       	out	0x3e, r29	; 62
     f92:	0f be       	out	0x3f, r0	; 63
     f94:	cd bf       	out	0x3d, r28	; 61
     f96:	df 91       	pop	r29
     f98:	cf 91       	pop	r28
     f9a:	0f 91       	pop	r16
     f9c:	ff 90       	pop	r15
     f9e:	ef 90       	pop	r14
     fa0:	df 90       	pop	r13
     fa2:	cf 90       	pop	r12
     fa4:	bf 90       	pop	r11
     fa6:	af 90       	pop	r10
     fa8:	08 95       	ret

00000faa <dispaly_integer>:
			
			}
		}
}
void dispaly_integer (int n, int n_count)
{	
     faa:	ef 92       	push	r14
     fac:	ff 92       	push	r15
     fae:	0f 93       	push	r16
     fb0:	1f 93       	push	r17
     fb2:	cf 93       	push	r28
     fb4:	df 93       	push	r29
     fb6:	cd b7       	in	r28, 0x3d	; 61
     fb8:	de b7       	in	r29, 0x3e	; 62
     fba:	60 97       	sbiw	r28, 0x10	; 16
     fbc:	0f b6       	in	r0, 0x3f	; 63
     fbe:	f8 94       	cli
     fc0:	de bf       	out	0x3e, r29	; 62
     fc2:	0f be       	out	0x3f, r0	; 63
     fc4:	cd bf       	out	0x3d, r28	; 61
     fc6:	7b 01       	movw	r14, r22
	unsigned char str[16];
	 sprintf(str, "%d", n);
     fc8:	9f 93       	push	r25
     fca:	8f 93       	push	r24
     fcc:	88 e8       	ldi	r24, 0x88	; 136
     fce:	90 e0       	ldi	r25, 0x00	; 0
     fd0:	9f 93       	push	r25
     fd2:	8f 93       	push	r24
     fd4:	ce 01       	movw	r24, r28
     fd6:	01 96       	adiw	r24, 0x01	; 1
     fd8:	9f 93       	push	r25
     fda:	8f 93       	push	r24
     fdc:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <sprintf>
	 for(int count = 0 ; count < n_count ; count++)
     fe0:	0f 90       	pop	r0
     fe2:	0f 90       	pop	r0
     fe4:	0f 90       	pop	r0
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
     fec:	1e 14       	cp	r1, r14
     fee:	1f 04       	cpc	r1, r15
     ff0:	6c f4       	brge	.+26     	; 0x100c <dispaly_integer+0x62>
     ff2:	8e 01       	movw	r16, r28
     ff4:	0f 5f       	subi	r16, 0xFF	; 255
     ff6:	1f 4f       	sbci	r17, 0xFF	; 255
     ff8:	e0 0e       	add	r14, r16
     ffa:	f1 1e       	adc	r15, r17
	 {
		 lcd_displayChar((unsigned char)str[count]);
     ffc:	f8 01       	movw	r30, r16
     ffe:	81 91       	ld	r24, Z+
    1000:	8f 01       	movw	r16, r30
    1002:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>
}
void dispaly_integer (int n, int n_count)
{	
	unsigned char str[16];
	 sprintf(str, "%d", n);
	 for(int count = 0 ; count < n_count ; count++)
    1006:	0e 15       	cp	r16, r14
    1008:	1f 05       	cpc	r17, r15
    100a:	c1 f7       	brne	.-16     	; 0xffc <dispaly_integer+0x52>
	 {
		 lcd_displayChar((unsigned char)str[count]);
	 }

}
    100c:	60 96       	adiw	r28, 0x10	; 16
    100e:	0f b6       	in	r0, 0x3f	; 63
    1010:	f8 94       	cli
    1012:	de bf       	out	0x3e, r29	; 62
    1014:	0f be       	out	0x3f, r0	; 63
    1016:	cd bf       	out	0x3d, r28	; 61
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	ff 90       	pop	r15
    1022:	ef 90       	pop	r14
    1024:	08 95       	ret

00001026 <calc_operation>:
	static int result=0;
	static int operator1_int=0;
	static int operator2_int=0;
	static unsigned char current_position = 0;
	
		if (xSemaphoreTake(button_data , portMAX_DELAY) == pdTRUE)
    1026:	20 e0       	ldi	r18, 0x00	; 0
    1028:	4f ef       	ldi	r20, 0xFF	; 255
    102a:	5f ef       	ldi	r21, 0xFF	; 255
    102c:	60 e0       	ldi	r22, 0x00	; 0
    102e:	70 e0       	ldi	r23, 0x00	; 0
    1030:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <button_data>
    1034:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <button_data+0x1>
    1038:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
    103c:	81 30       	cpi	r24, 0x01	; 1
    103e:	09 f0       	breq	.+2      	; 0x1042 <calc_operation+0x1c>
    1040:	05 c1       	rjmp	.+522    	; 0x124c <calc_operation+0x226>
		{	
			if (pressed_button <= '9' && pressed_button >= '0')
    1042:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <pressed_button>
    1046:	90 ed       	ldi	r25, 0xD0	; 208
    1048:	98 0f       	add	r25, r24
    104a:	9a 30       	cpi	r25, 0x0A	; 10
    104c:	60 f5       	brcc	.+88     	; 0x10a6 <calc_operation+0x80>
			{
				lcd_gotoxy(0,current_position);
    104e:	60 91 aa 06 	lds	r22, 0x06AA	; 0x8006aa <current_position.2258>
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	0e 94 c5 01 	call	0x38a	; 0x38a <lcd_gotoxy>
				current_position++;
    1058:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <current_position.2258>
    105c:	8f 5f       	subi	r24, 0xFF	; 255
    105e:	80 93 aa 06 	sts	0x06AA, r24	; 0x8006aa <current_position.2258>
				lcd_displayChar(pressed_button);
    1062:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <pressed_button>
    1066:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>
				
				if (operator1_complete == 0)
    106a:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <operator1_complete.2254>
    106e:	81 11       	cpse	r24, r1
    1070:	0d c0       	rjmp	.+26     	; 0x108c <calc_operation+0x66>
				{
					operator1[operator1_count]=pressed_button;
    1072:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <operator1_count.2250>
    1076:	e8 2f       	mov	r30, r24
    1078:	f0 e0       	ldi	r31, 0x00	; 0
    107a:	e8 56       	subi	r30, 0x68	; 104
    107c:	f9 4f       	sbci	r31, 0xF9	; 249
    107e:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <pressed_button>
    1082:	90 83       	st	Z, r25
					operator1_count++;
    1084:	8f 5f       	subi	r24, 0xFF	; 255
    1086:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <operator1_count.2250>
    108a:	08 95       	ret
			
				}
				else 
				{
					operator2[operator2_count]=pressed_button;
    108c:	80 91 97 06 	lds	r24, 0x0697	; 0x800697 <operator2_count.2252>
    1090:	e8 2f       	mov	r30, r24
    1092:	f0 e0       	ldi	r31, 0x00	; 0
    1094:	e9 57       	subi	r30, 0x79	; 121
    1096:	f9 4f       	sbci	r31, 0xF9	; 249
    1098:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <pressed_button>
    109c:	90 83       	st	Z, r25
					operator2_count++;
    109e:	8f 5f       	subi	r24, 0xFF	; 255
    10a0:	80 93 97 06 	sts	0x0697, r24	; 0x800697 <operator2_count.2252>
    10a4:	08 95       	ret
				}
			}
			else
			{
				if (pressed_button == '=')
    10a6:	8d 33       	cpi	r24, 0x3D	; 61
    10a8:	09 f0       	breq	.+2      	; 0x10ac <calc_operation+0x86>
    10aa:	a6 c0       	rjmp	.+332    	; 0x11f8 <calc_operation+0x1d2>
				{	
					operator1_int = atoi(operator1);
    10ac:	88 e9       	ldi	r24, 0x98	; 152
    10ae:	96 e0       	ldi	r25, 0x06	; 6
    10b0:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <atoi>
    10b4:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <operator1_int.2256+0x1>
    10b8:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <operator1_int.2256>
					operator2_int = atoi(operator2);
    10bc:	87 e8       	ldi	r24, 0x87	; 135
    10be:	96 e0       	ldi	r25, 0x06	; 6
    10c0:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <atoi>
    10c4:	bc 01       	movw	r22, r24
					switch (equation_op)
    10c6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
    10ca:	8b 32       	cpi	r24, 0x2B	; 43
    10cc:	49 f0       	breq	.+18     	; 0x10e0 <calc_operation+0xba>
    10ce:	18 f4       	brcc	.+6      	; 0x10d6 <calc_operation+0xb0>
    10d0:	8a 32       	cpi	r24, 0x2A	; 42
    10d2:	e1 f0       	breq	.+56     	; 0x110c <calc_operation+0xe6>
    10d4:	61 c0       	rjmp	.+194    	; 0x1198 <calc_operation+0x172>
    10d6:	8d 32       	cpi	r24, 0x2D	; 45
    10d8:	71 f0       	breq	.+28     	; 0x10f6 <calc_operation+0xd0>
    10da:	8f 32       	cpi	r24, 0x2F	; 47
    10dc:	39 f1       	breq	.+78     	; 0x112c <calc_operation+0x106>
    10de:	5c c0       	rjmp	.+184    	; 0x1198 <calc_operation+0x172>
					{
						case '+':
							result = operator1_int+operator2_int;
    10e0:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <operator1_int.2256>
    10e4:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <operator1_int.2256+0x1>
    10e8:	68 0f       	add	r22, r24
    10ea:	79 1f       	adc	r23, r25
    10ec:	70 93 84 06 	sts	0x0684, r23	; 0x800684 <result.2255+0x1>
    10f0:	60 93 83 06 	sts	0x0683, r22	; 0x800683 <result.2255>
						break;
    10f4:	51 c0       	rjmp	.+162    	; 0x1198 <calc_operation+0x172>
						case '-':
							result = operator1_int-operator2_int;
    10f6:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <operator1_int.2256>
    10fa:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <operator1_int.2256+0x1>
    10fe:	86 1b       	sub	r24, r22
    1100:	97 0b       	sbc	r25, r23
    1102:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <result.2255+0x1>
    1106:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <result.2255>
						break;
    110a:	46 c0       	rjmp	.+140    	; 0x1198 <calc_operation+0x172>
						case '*':
							result = operator1_int*operator2_int;
    110c:	20 91 85 06 	lds	r18, 0x0685	; 0x800685 <operator1_int.2256>
    1110:	30 91 86 06 	lds	r19, 0x0686	; 0x800686 <operator1_int.2256+0x1>
    1114:	26 9f       	mul	r18, r22
    1116:	c0 01       	movw	r24, r0
    1118:	27 9f       	mul	r18, r23
    111a:	90 0d       	add	r25, r0
    111c:	36 9f       	mul	r19, r22
    111e:	90 0d       	add	r25, r0
    1120:	11 24       	eor	r1, r1
    1122:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <result.2255+0x1>
    1126:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <result.2255>
						break;													
    112a:	36 c0       	rjmp	.+108    	; 0x1198 <calc_operation+0x172>
						case '/':
							if(operator2_int == 0)
    112c:	61 15       	cp	r22, r1
    112e:	71 05       	cpc	r23, r1
    1130:	49 f5       	brne	.+82     	; 0x1184 <calc_operation+0x15e>
							{
								lcd_disp_string_xy("Math Error",0,0);
    1132:	40 e0       	ldi	r20, 0x00	; 0
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	60 e0       	ldi	r22, 0x00	; 0
    1138:	70 e0       	ldi	r23, 0x00	; 0
    113a:	8b e8       	ldi	r24, 0x8B	; 139
    113c:	90 e0       	ldi	r25, 0x00	; 0
    113e:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
								vTaskDelay(500);	
    1142:	84 ef       	ldi	r24, 0xF4	; 244
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
								lcd_clrScreen();
    114a:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
								lcd_displayChar('0');
    114e:	80 e3       	ldi	r24, 0x30	; 48
    1150:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>
								current_position =0;
    1154:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <current_position.2258>
								operator1_complete = 0;
    1158:	10 92 a9 06 	sts	0x06A9, r1	; 0x8006a9 <operator1_complete.2254>
								operator1_count = 0;
    115c:	10 92 a8 06 	sts	0x06A8, r1	; 0x8006a8 <operator1_count.2250>
    1160:	e8 e9       	ldi	r30, 0x98	; 152
    1162:	f6 e0       	ldi	r31, 0x06	; 6
    1164:	a7 e8       	ldi	r26, 0x87	; 135
    1166:	b6 e0       	ldi	r27, 0x06	; 6
    1168:	88 ea       	ldi	r24, 0xA8	; 168
    116a:	96 e0       	ldi	r25, 0x06	; 6
								for (int i = 0 ; i< 16 ; i++)
								{
									operator1[i] = 0;
    116c:	11 92       	st	Z+, r1
									operator2[i] = 0;
    116e:	1d 92       	st	X+, r1
								lcd_clrScreen();
								lcd_displayChar('0');
								current_position =0;
								operator1_complete = 0;
								operator1_count = 0;
								for (int i = 0 ; i< 16 ; i++)
    1170:	e8 17       	cp	r30, r24
    1172:	f9 07       	cpc	r31, r25
    1174:	d9 f7       	brne	.-10     	; 0x116c <calc_operation+0x146>
								{
									operator1[i] = 0;
									operator2[i] = 0;
								}
								operator2_count =0;
    1176:	10 92 97 06 	sts	0x0697, r1	; 0x800697 <operator2_count.2252>
								result = 0;
    117a:	10 92 84 06 	sts	0x0684, r1	; 0x800684 <result.2255+0x1>
    117e:	10 92 83 06 	sts	0x0683, r1	; 0x800683 <result.2255>
    1182:	0a c0       	rjmp	.+20     	; 0x1198 <calc_operation+0x172>
							}
							else
								result = operator1_int/operator2_int;
    1184:	80 91 85 06 	lds	r24, 0x0685	; 0x800685 <operator1_int.2256>
    1188:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <operator1_int.2256+0x1>
    118c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <__divmodhi4>
    1190:	70 93 84 06 	sts	0x0684, r23	; 0x800684 <result.2255+0x1>
    1194:	60 93 83 06 	sts	0x0683, r22	; 0x800683 <result.2255>
						break;						
					}
					
					lcd_clrScreen();
    1198:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
					dispaly_integer(result,operator1_count+operator2_count);
    119c:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <operator1_count.2250>
    11a0:	60 91 97 06 	lds	r22, 0x0697	; 0x800697 <operator2_count.2252>
    11a4:	70 e0       	ldi	r23, 0x00	; 0
    11a6:	68 0f       	add	r22, r24
    11a8:	71 1d       	adc	r23, r1
    11aa:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <result.2255>
    11ae:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <result.2255+0x1>
    11b2:	0e 94 d5 07 	call	0xfaa	; 0xfaa <dispaly_integer>

					sprintf(operator1, "%d", result);
    11b6:	80 91 84 06 	lds	r24, 0x0684	; 0x800684 <result.2255+0x1>
    11ba:	8f 93       	push	r24
    11bc:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <result.2255>
    11c0:	8f 93       	push	r24
    11c2:	88 e8       	ldi	r24, 0x88	; 136
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	9f 93       	push	r25
    11c8:	8f 93       	push	r24
    11ca:	88 e9       	ldi	r24, 0x98	; 152
    11cc:	96 e0       	ldi	r25, 0x06	; 6
    11ce:	9f 93       	push	r25
    11d0:	8f 93       	push	r24
    11d2:	0e 94 e1 0e 	call	0x1dc2	; 0x1dc2 <sprintf>
    11d6:	e7 e8       	ldi	r30, 0x87	; 135
    11d8:	f6 e0       	ldi	r31, 0x06	; 6
    11da:	87 e9       	ldi	r24, 0x97	; 151
    11dc:	96 e0       	ldi	r25, 0x06	; 6
    11de:	0f 90       	pop	r0
    11e0:	0f 90       	pop	r0
    11e2:	0f 90       	pop	r0
    11e4:	0f 90       	pop	r0
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
					for (int i = 0 ; i< 16 ; i++)
					{
						operator2[i] = 0;
    11ea:	11 92       	st	Z+, r1
					
					lcd_clrScreen();
					dispaly_integer(result,operator1_count+operator2_count);

					sprintf(operator1, "%d", result);
					for (int i = 0 ; i< 16 ; i++)
    11ec:	8e 17       	cp	r24, r30
    11ee:	9f 07       	cpc	r25, r31
    11f0:	e1 f7       	brne	.-8      	; 0x11ea <calc_operation+0x1c4>
					{
						operator2[i] = 0;
					}
					operator2_count =0;
    11f2:	10 92 97 06 	sts	0x0697, r1	; 0x800697 <operator2_count.2252>
    11f6:	08 95       	ret
				}
				else if (pressed_button == 13)
    11f8:	8d 30       	cpi	r24, 0x0D	; 13
    11fa:	e9 f4       	brne	.+58     	; 0x1236 <calc_operation+0x210>
				{
					lcd_clrScreen();
    11fc:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
					
					lcd_displayChar('0');
    1200:	80 e3       	ldi	r24, 0x30	; 48
    1202:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>
					current_position =0;
    1206:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <current_position.2258>
					operator1_complete = 0;
    120a:	10 92 a9 06 	sts	0x06A9, r1	; 0x8006a9 <operator1_complete.2254>
					operator1_count = 0;
    120e:	10 92 a8 06 	sts	0x06A8, r1	; 0x8006a8 <operator1_count.2250>
    1212:	e8 e9       	ldi	r30, 0x98	; 152
    1214:	f6 e0       	ldi	r31, 0x06	; 6
    1216:	a7 e8       	ldi	r26, 0x87	; 135
    1218:	b6 e0       	ldi	r27, 0x06	; 6
    121a:	88 ea       	ldi	r24, 0xA8	; 168
    121c:	96 e0       	ldi	r25, 0x06	; 6
					for (int i = 0 ; i< 16 ; i++)
					{
						operator1[i] = 0;
    121e:	11 92       	st	Z+, r1
						operator2[i] = 0;
    1220:	1d 92       	st	X+, r1
					
					lcd_displayChar('0');
					current_position =0;
					operator1_complete = 0;
					operator1_count = 0;
					for (int i = 0 ; i< 16 ; i++)
    1222:	e8 17       	cp	r30, r24
    1224:	f9 07       	cpc	r31, r25
    1226:	d9 f7       	brne	.-10     	; 0x121e <calc_operation+0x1f8>
					{
						operator1[i] = 0;
						operator2[i] = 0;
					}
					operator2_count =0;
    1228:	10 92 97 06 	sts	0x0697, r1	; 0x800697 <operator2_count.2252>
					result = 0;
    122c:	10 92 84 06 	sts	0x0684, r1	; 0x800684 <result.2255+0x1>
    1230:	10 92 83 06 	sts	0x0683, r1	; 0x800683 <result.2255>
    1234:	08 95       	ret
				}
				else 
				{
					lcd_clrScreen();
    1236:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
					current_position=0;
    123a:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <current_position.2258>
						equation_op = pressed_button;
    123e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <pressed_button>
    1242:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
						operator1_complete =1;
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <operator1_complete.2254>
    124c:	08 95       	ret

0000124e <calc>:
	}
	vTaskDelete(NULL);
}

void calc (void *p)
{
    124e:	cf 93       	push	r28
    1250:	df 93       	push	r29
    1252:	00 d0       	rcall	.+0      	; 0x1254 <calc+0x6>
    1254:	cd b7       	in	r28, 0x3d	; 61
    1256:	de b7       	in	r29, 0x3e	; 62
	static unsigned char calc_started = 0;
	portTickType wait = xTaskGetTickCount();
    1258:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
    125c:	9a 83       	std	Y+2, r25	; 0x02
    125e:	89 83       	std	Y+1, r24	; 0x01
	vTaskDelay(3000);
    1260:	88 eb       	ldi	r24, 0xB8	; 184
    1262:	9b e0       	ldi	r25, 0x0B	; 11
    1264:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
		vTaskDelayUntil (&wait , 100);
		if(calc_started == 0)
		{
			if (xSemaphoreTake(calc_start,portMAX_DELAY) == pdTRUE)
			{
				calc_started = 1;
    1268:	11 e0       	ldi	r17, 0x01	; 1
	portTickType wait = xTaskGetTickCount();
	vTaskDelay(3000);

	for(;;)
	{
		vTaskDelayUntil (&wait , 100);
    126a:	64 e6       	ldi	r22, 0x64	; 100
    126c:	70 e0       	ldi	r23, 0x00	; 0
    126e:	ce 01       	movw	r24, r28
    1270:	01 96       	adiw	r24, 0x01	; 1
    1272:	0e 94 be 0c 	call	0x197c	; 0x197c <vTaskDelayUntil>
		if(calc_started == 0)
    1276:	80 91 ab 06 	lds	r24, 0x06AB	; 0x8006ab <calc_started.2236>
    127a:	81 11       	cpse	r24, r1
    127c:	15 c0       	rjmp	.+42     	; 0x12a8 <calc+0x5a>
		{
			if (xSemaphoreTake(calc_start,portMAX_DELAY) == pdTRUE)
    127e:	20 e0       	ldi	r18, 0x00	; 0
    1280:	4f ef       	ldi	r20, 0xFF	; 255
    1282:	5f ef       	ldi	r21, 0xFF	; 255
    1284:	60 e0       	ldi	r22, 0x00	; 0
    1286:	70 e0       	ldi	r23, 0x00	; 0
    1288:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <calc_start>
    128c:	90 91 13 07 	lds	r25, 0x0713	; 0x800713 <calc_start+0x1>
    1290:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
    1294:	81 30       	cpi	r24, 0x01	; 1
    1296:	49 f7       	brne	.-46     	; 0x126a <calc+0x1c>
			{
				calc_started = 1;
    1298:	10 93 ab 06 	sts	0x06AB, r17	; 0x8006ab <calc_started.2236>
				lcd_clrScreen();
    129c:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
				lcd_displayChar('0');
    12a0:	80 e3       	ldi	r24, 0x30	; 48
    12a2:	0e 94 ab 01 	call	0x356	; 0x356 <lcd_displayChar>
				continue;
    12a6:	e1 cf       	rjmp	.-62     	; 0x126a <calc+0x1c>
			}
		}
		else
		{
			calc_operation();
    12a8:	0e 94 13 08 	call	0x1026	; 0x1026 <calc_operation>
    12ac:	de cf       	rjmp	.-68     	; 0x126a <calc+0x1c>

000012ae <pwm_init>:
	 }

}
void pwm_init()
{
	TCCR2 |= (1<<WGM00)|(1<<COM01)|(1<<WGM01)|(1<<CS00);
    12ae:	85 b5       	in	r24, 0x25	; 37
    12b0:	89 66       	ori	r24, 0x69	; 105
    12b2:	85 bd       	out	0x25, r24	; 37
	
	DDRD |= (1<<7);
    12b4:	8f 9a       	sbi	0x11, 7	; 17
	OCR2 = 0;
    12b6:	13 bc       	out	0x23, r1	; 35
    12b8:	08 95       	ret

000012ba <led_operation>:
}

void led_operation(void)
{
    12ba:	cf 93       	push	r28
	
	pwm_init();
    12bc:	0e 94 57 09 	call	0x12ae	; 0x12ae <pwm_init>
    12c0:	c0 e0       	ldi	r28, 0x00	; 0

for ( int brightness = 0 ; brightness < 255 ; brightness += 10)
{
	OCR2 = brightness;
    12c2:	c3 bd       	out	0x23, r28	; 35
	vTaskDelay(10);
    12c4:	8a e0       	ldi	r24, 0x0A	; 10
    12c6:	90 e0       	ldi	r25, 0x00	; 0
    12c8:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
    12cc:	c6 5f       	subi	r28, 0xF6	; 246
void led_operation(void)
{
	
	pwm_init();

for ( int brightness = 0 ; brightness < 255 ; brightness += 10)
    12ce:	c4 30       	cpi	r28, 0x04	; 4
    12d0:	c1 f7       	brne	.-16     	; 0x12c2 <led_operation+0x8>
{
	OCR2 = brightness;
	vTaskDelay(10);
}
vTaskDelay(250);
    12d2:	8a ef       	ldi	r24, 0xFA	; 250
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
    12da:	cf ef       	ldi	r28, 0xFF	; 255
for ( int brightness = 255 ; brightness > 0 ; brightness -= 10)
{
	OCR2 = brightness;
    12dc:	c3 bd       	out	0x23, r28	; 35
	vTaskDelay(10);
    12de:	8a e0       	ldi	r24, 0x0A	; 10
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
    12e6:	ca 50       	subi	r28, 0x0A	; 10
{
	OCR2 = brightness;
	vTaskDelay(10);
}
vTaskDelay(250);
for ( int brightness = 255 ; brightness > 0 ; brightness -= 10)
    12e8:	cb 3f       	cpi	r28, 0xFB	; 251
    12ea:	c1 f7       	brne	.-16     	; 0x12dc <led_operation+0x22>
{
	OCR2 = brightness;
	vTaskDelay(10);
}
vTaskDelay(250);
    12ec:	8a ef       	ldi	r24, 0xFA	; 250
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>

TCCR2 = 0x00;
    12f4:	15 bc       	out	0x25, r1	; 37
	lcd_clrScreen();
    12f6:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
}
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <led>:
	}
	vTaskDelete(NULL);
}

void led (void *p)
{
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	00 d0       	rcall	.+0      	; 0x1304 <led+0x6>
    1304:	cd b7       	in	r28, 0x3d	; 61
    1306:	de b7       	in	r29, 0x3e	; 62
	unsigned char led_started = 0;
	portTickType wait = xTaskGetTickCount();
    1308:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <xTaskGetTickCount>
    130c:	9a 83       	std	Y+2, r25	; 0x02
    130e:	89 83       	std	Y+1, r24	; 0x01
	vTaskDelay(3000);
    1310:	88 eb       	ldi	r24, 0xB8	; 184
    1312:	9b e0       	ldi	r25, 0x0B	; 11
    1314:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <vTaskDelay>
	vTaskDelete(NULL);
}

void led (void *p)
{
	unsigned char led_started = 0;
    1318:	10 e0       	ldi	r17, 0x00	; 0
		vTaskDelayUntil (&wait , 25);
		if (led_started == 0)
		{
			if (xSemaphoreTake(led_start,portMAX_DELAY) == pdTRUE)
			{	
				led_started = 1;
    131a:	01 e0       	ldi	r16, 0x01	; 1
	unsigned char led_started = 0;
	portTickType wait = xTaskGetTickCount();
	vTaskDelay(3000);
	while (1)
	{
		vTaskDelayUntil (&wait , 25);
    131c:	69 e1       	ldi	r22, 0x19	; 25
    131e:	70 e0       	ldi	r23, 0x00	; 0
    1320:	ce 01       	movw	r24, r28
    1322:	01 96       	adiw	r24, 0x01	; 1
    1324:	0e 94 be 0c 	call	0x197c	; 0x197c <vTaskDelayUntil>
		if (led_started == 0)
    1328:	11 11       	cpse	r17, r1
    132a:	f8 cf       	rjmp	.-16     	; 0x131c <led+0x1e>
		{
			if (xSemaphoreTake(led_start,portMAX_DELAY) == pdTRUE)
    132c:	20 e0       	ldi	r18, 0x00	; 0
    132e:	4f ef       	ldi	r20, 0xFF	; 255
    1330:	5f ef       	ldi	r21, 0xFF	; 255
    1332:	60 e0       	ldi	r22, 0x00	; 0
    1334:	70 e0       	ldi	r23, 0x00	; 0
    1336:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <led_start>
    133a:	90 91 17 07 	lds	r25, 0x0717	; 0x800717 <led_start+0x1>
    133e:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
    1342:	81 30       	cpi	r24, 0x01	; 1
    1344:	59 f7       	brne	.-42     	; 0x131c <led+0x1e>
			{	
				led_started = 1;
				lcd_clrScreen();
    1346:	0e 94 dd 01 	call	0x3ba	; 0x3ba <lcd_clrScreen>
				lcd_disp_string_xy("Stand By",0,0);
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	60 e0       	ldi	r22, 0x00	; 0
    1350:	70 e0       	ldi	r23, 0x00	; 0
    1352:	86 e9       	ldi	r24, 0x96	; 150
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <lcd_disp_string_xy>
				led_operation();
    135a:	0e 94 5d 09 	call	0x12ba	; 0x12ba <led_operation>
		vTaskDelayUntil (&wait , 25);
		if (led_started == 0)
		{
			if (xSemaphoreTake(led_start,portMAX_DELAY) == pdTRUE)
			{	
				led_started = 1;
    135e:	10 2f       	mov	r17, r16
    1360:	dd cf       	rjmp	.-70     	; 0x131c <led+0x1e>

00001362 <prvAddCurrentTaskToDelayedList>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1362:	cf 93       	push	r28
    1364:	df 93       	push	r29
    1366:	ec 01       	movw	r28, r24
    1368:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <pxCurrentTCB>
    136c:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1370:	93 83       	std	Z+3, r25	; 0x03
    1372:	82 83       	std	Z+2, r24	; 0x02
    1374:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1378:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    137c:	c8 17       	cp	r28, r24
    137e:	d9 07       	cpc	r29, r25
    1380:	68 f4       	brcc	.+26     	; 0x139c <prvAddCurrentTaskToDelayedList+0x3a>
    1382:	60 91 0e 07 	lds	r22, 0x070E	; 0x80070e <pxCurrentTCB>
    1386:	70 91 0f 07 	lds	r23, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    138a:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <pxOverflowDelayedTaskList>
    138e:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <pxOverflowDelayedTaskList+0x1>
    1392:	6e 5f       	subi	r22, 0xFE	; 254
    1394:	7f 4f       	sbci	r23, 0xFF	; 255
    1396:	0e 94 36 02 	call	0x46c	; 0x46c <vListInsert>
    139a:	17 c0       	rjmp	.+46     	; 0x13ca <prvAddCurrentTaskToDelayedList+0x68>
    139c:	60 91 0e 07 	lds	r22, 0x070E	; 0x80070e <pxCurrentTCB>
    13a0:	70 91 0f 07 	lds	r23, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    13a4:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    13a8:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    13ac:	6e 5f       	subi	r22, 0xFE	; 254
    13ae:	7f 4f       	sbci	r23, 0xFF	; 255
    13b0:	0e 94 36 02 	call	0x46c	; 0x46c <vListInsert>
    13b4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <xNextTaskUnblockTime>
    13b8:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <xNextTaskUnblockTime+0x1>
    13bc:	c8 17       	cp	r28, r24
    13be:	d9 07       	cpc	r29, r25
    13c0:	20 f4       	brcc	.+8      	; 0x13ca <prvAddCurrentTaskToDelayedList+0x68>
    13c2:	d0 93 63 00 	sts	0x0063, r29	; 0x800063 <xNextTaskUnblockTime+0x1>
    13c6:	c0 93 62 00 	sts	0x0062, r28	; 0x800062 <xNextTaskUnblockTime>
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	08 95       	ret

000013d0 <xTaskGenericCreate>:
    13d0:	4f 92       	push	r4
    13d2:	5f 92       	push	r5
    13d4:	6f 92       	push	r6
    13d6:	7f 92       	push	r7
    13d8:	8f 92       	push	r8
    13da:	9f 92       	push	r9
    13dc:	af 92       	push	r10
    13de:	bf 92       	push	r11
    13e0:	cf 92       	push	r12
    13e2:	df 92       	push	r13
    13e4:	ef 92       	push	r14
    13e6:	ff 92       	push	r15
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	5c 01       	movw	r10, r24
    13f2:	4b 01       	movw	r8, r22
    13f4:	ea 01       	movw	r28, r20
    13f6:	29 01       	movw	r4, r18
    13f8:	81 e2       	ldi	r24, 0x21	; 33
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <pvPortMalloc>
    1400:	3c 01       	movw	r6, r24
    1402:	00 97       	sbiw	r24, 0x00	; 0
    1404:	09 f4       	brne	.+2      	; 0x1408 <xTaskGenericCreate+0x38>
    1406:	db c0       	rjmp	.+438    	; 0x15be <xTaskGenericCreate+0x1ee>
    1408:	c1 14       	cp	r12, r1
    140a:	d1 04       	cpc	r13, r1
    140c:	09 f0       	breq	.+2      	; 0x1410 <xTaskGenericCreate+0x40>
    140e:	d2 c0       	rjmp	.+420    	; 0x15b4 <xTaskGenericCreate+0x1e4>
    1410:	ce 01       	movw	r24, r28
    1412:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <pvPortMalloc>
    1416:	f3 01       	movw	r30, r6
    1418:	90 8f       	std	Z+24, r25	; 0x18
    141a:	87 8b       	std	Z+23, r24	; 0x17
    141c:	00 97       	sbiw	r24, 0x00	; 0
    141e:	21 f4       	brne	.+8      	; 0x1428 <xTaskGenericCreate+0x58>
    1420:	c3 01       	movw	r24, r6
    1422:	0e 94 06 01 	call	0x20c	; 0x20c <vPortFree>
    1426:	cb c0       	rjmp	.+406    	; 0x15be <xTaskGenericCreate+0x1ee>
    1428:	ae 01       	movw	r20, r28
    142a:	65 ea       	ldi	r22, 0xA5	; 165
    142c:	70 e0       	ldi	r23, 0x00	; 0
    142e:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <memset>
    1432:	21 97       	sbiw	r28, 0x01	; 1
    1434:	f3 01       	movw	r30, r6
    1436:	87 89       	ldd	r24, Z+23	; 0x17
    1438:	90 8d       	ldd	r25, Z+24	; 0x18
    143a:	c8 0f       	add	r28, r24
    143c:	d9 1f       	adc	r29, r25
    143e:	48 e0       	ldi	r20, 0x08	; 8
    1440:	50 e0       	ldi	r21, 0x00	; 0
    1442:	b4 01       	movw	r22, r8
    1444:	c3 01       	movw	r24, r6
    1446:	49 96       	adiw	r24, 0x19	; 25
    1448:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <strncpy>
    144c:	f3 01       	movw	r30, r6
    144e:	10 a2       	std	Z+32, r1	; 0x20
    1450:	10 2f       	mov	r17, r16
    1452:	05 30       	cpi	r16, 0x05	; 5
    1454:	08 f0       	brcs	.+2      	; 0x1458 <xTaskGenericCreate+0x88>
    1456:	14 e0       	ldi	r17, 0x04	; 4
    1458:	f3 01       	movw	r30, r6
    145a:	16 8b       	std	Z+22, r17	; 0x16
    145c:	63 01       	movw	r12, r6
    145e:	f2 e0       	ldi	r31, 0x02	; 2
    1460:	cf 0e       	add	r12, r31
    1462:	d1 1c       	adc	r13, r1
    1464:	c6 01       	movw	r24, r12
    1466:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialiseItem>
    146a:	c3 01       	movw	r24, r6
    146c:	0c 96       	adiw	r24, 0x0c	; 12
    146e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialiseItem>
    1472:	f3 01       	movw	r30, r6
    1474:	71 86       	std	Z+9, r7	; 0x09
    1476:	60 86       	std	Z+8, r6	; 0x08
    1478:	85 e0       	ldi	r24, 0x05	; 5
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	81 1b       	sub	r24, r17
    147e:	91 09       	sbc	r25, r1
    1480:	95 87       	std	Z+13, r25	; 0x0d
    1482:	84 87       	std	Z+12, r24	; 0x0c
    1484:	73 8a       	std	Z+19, r7	; 0x13
    1486:	62 8a       	std	Z+18, r6	; 0x12
    1488:	a2 01       	movw	r20, r4
    148a:	b5 01       	movw	r22, r10
    148c:	ce 01       	movw	r24, r28
    148e:	0e 94 97 02 	call	0x52e	; 0x52e <pxPortInitialiseStack>
    1492:	f3 01       	movw	r30, r6
    1494:	91 83       	std	Z+1, r25	; 0x01
    1496:	80 83       	st	Z, r24
    1498:	e1 14       	cp	r14, r1
    149a:	f1 04       	cpc	r15, r1
    149c:	19 f0       	breq	.+6      	; 0x14a4 <xTaskGenericCreate+0xd4>
    149e:	f7 01       	movw	r30, r14
    14a0:	71 82       	std	Z+1, r7	; 0x01
    14a2:	60 82       	st	Z, r6
    14a4:	0f b6       	in	r0, 0x3f	; 63
    14a6:	f8 94       	cli
    14a8:	0f 92       	push	r0
    14aa:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <uxCurrentNumberOfTasks>
    14ae:	8f 5f       	subi	r24, 0xFF	; 255
    14b0:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <uxCurrentNumberOfTasks>
    14b4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <pxCurrentTCB>
    14b8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    14bc:	89 2b       	or	r24, r25
    14be:	a1 f5       	brne	.+104    	; 0x1528 <xTaskGenericCreate+0x158>
    14c0:	70 92 0f 07 	sts	0x070F, r7	; 0x80070f <pxCurrentTCB+0x1>
    14c4:	60 92 0e 07 	sts	0x070E, r6	; 0x80070e <pxCurrentTCB>
    14c8:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <uxCurrentNumberOfTasks>
    14cc:	81 30       	cpi	r24, 0x01	; 1
    14ce:	d9 f5       	brne	.+118    	; 0x1546 <xTaskGenericCreate+0x176>
    14d0:	c1 ee       	ldi	r28, 0xE1	; 225
    14d2:	d6 e0       	ldi	r29, 0x06	; 6
    14d4:	0f 2e       	mov	r0, r31
    14d6:	fe e0       	ldi	r31, 0x0E	; 14
    14d8:	ef 2e       	mov	r14, r31
    14da:	f7 e0       	ldi	r31, 0x07	; 7
    14dc:	ff 2e       	mov	r15, r31
    14de:	f0 2d       	mov	r31, r0
    14e0:	ce 01       	movw	r24, r28
    14e2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
    14e6:	29 96       	adiw	r28, 0x09	; 9
    14e8:	ce 15       	cp	r28, r14
    14ea:	df 05       	cpc	r29, r15
    14ec:	c9 f7       	brne	.-14     	; 0x14e0 <xTaskGenericCreate+0x110>
    14ee:	88 ed       	ldi	r24, 0xD8	; 216
    14f0:	96 e0       	ldi	r25, 0x06	; 6
    14f2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
    14f6:	8f ec       	ldi	r24, 0xCF	; 207
    14f8:	96 e0       	ldi	r25, 0x06	; 6
    14fa:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
    14fe:	82 ec       	ldi	r24, 0xC2	; 194
    1500:	96 e0       	ldi	r25, 0x06	; 6
    1502:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
    1506:	89 eb       	ldi	r24, 0xB9	; 185
    1508:	96 e0       	ldi	r25, 0x06	; 6
    150a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListInitialise>
    150e:	88 ed       	ldi	r24, 0xD8	; 216
    1510:	96 e0       	ldi	r25, 0x06	; 6
    1512:	90 93 ce 06 	sts	0x06CE, r25	; 0x8006ce <pxDelayedTaskList+0x1>
    1516:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <pxDelayedTaskList>
    151a:	8f ec       	ldi	r24, 0xCF	; 207
    151c:	96 e0       	ldi	r25, 0x06	; 6
    151e:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <pxOverflowDelayedTaskList+0x1>
    1522:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <pxOverflowDelayedTaskList>
    1526:	0f c0       	rjmp	.+30     	; 0x1546 <xTaskGenericCreate+0x176>
    1528:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <xSchedulerRunning>
    152c:	81 11       	cpse	r24, r1
    152e:	0b c0       	rjmp	.+22     	; 0x1546 <xTaskGenericCreate+0x176>
    1530:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <pxCurrentTCB>
    1534:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1538:	86 89       	ldd	r24, Z+22	; 0x16
    153a:	08 17       	cp	r16, r24
    153c:	20 f0       	brcs	.+8      	; 0x1546 <xTaskGenericCreate+0x176>
    153e:	70 92 0f 07 	sts	0x070F, r7	; 0x80070f <pxCurrentTCB+0x1>
    1542:	60 92 0e 07 	sts	0x070E, r6	; 0x80070e <pxCurrentTCB>
    1546:	f3 01       	movw	r30, r6
    1548:	86 89       	ldd	r24, Z+22	; 0x16
    154a:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <uxTopUsedPriority>
    154e:	98 17       	cp	r25, r24
    1550:	10 f4       	brcc	.+4      	; 0x1556 <xTaskGenericCreate+0x186>
    1552:	80 93 b4 06 	sts	0x06B4, r24	; 0x8006b4 <uxTopUsedPriority>
    1556:	90 91 ad 06 	lds	r25, 0x06AD	; 0x8006ad <uxTaskNumber>
    155a:	9f 5f       	subi	r25, 0xFF	; 255
    155c:	90 93 ad 06 	sts	0x06AD, r25	; 0x8006ad <uxTaskNumber>
    1560:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1564:	98 17       	cp	r25, r24
    1566:	10 f4       	brcc	.+4      	; 0x156c <xTaskGenericCreate+0x19c>
    1568:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <uxTopReadyPriority>
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	9c 01       	movw	r18, r24
    1570:	22 0f       	add	r18, r18
    1572:	33 1f       	adc	r19, r19
    1574:	22 0f       	add	r18, r18
    1576:	33 1f       	adc	r19, r19
    1578:	22 0f       	add	r18, r18
    157a:	33 1f       	adc	r19, r19
    157c:	82 0f       	add	r24, r18
    157e:	93 1f       	adc	r25, r19
    1580:	b6 01       	movw	r22, r12
    1582:	8f 51       	subi	r24, 0x1F	; 31
    1584:	99 4f       	sbci	r25, 0xF9	; 249
    1586:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>
    158a:	0f 90       	pop	r0
    158c:	0f be       	out	0x3f, r0	; 63
    158e:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <xSchedulerRunning>
    1592:	88 23       	and	r24, r24
    1594:	59 f0       	breq	.+22     	; 0x15ac <xTaskGenericCreate+0x1dc>
    1596:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <pxCurrentTCB>
    159a:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    159e:	86 89       	ldd	r24, Z+22	; 0x16
    15a0:	80 17       	cp	r24, r16
    15a2:	30 f4       	brcc	.+12     	; 0x15b0 <xTaskGenericCreate+0x1e0>
    15a4:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	0a c0       	rjmp	.+20     	; 0x15c0 <xTaskGenericCreate+0x1f0>
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	08 c0       	rjmp	.+16     	; 0x15c0 <xTaskGenericCreate+0x1f0>
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	06 c0       	rjmp	.+12     	; 0x15c0 <xTaskGenericCreate+0x1f0>
    15b4:	fc 01       	movw	r30, r24
    15b6:	d0 8e       	std	Z+24, r13	; 0x18
    15b8:	c7 8a       	std	Z+23, r12	; 0x17
    15ba:	c6 01       	movw	r24, r12
    15bc:	35 cf       	rjmp	.-406    	; 0x1428 <xTaskGenericCreate+0x58>
    15be:	8f ef       	ldi	r24, 0xFF	; 255
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	0f 91       	pop	r16
    15c8:	ff 90       	pop	r15
    15ca:	ef 90       	pop	r14
    15cc:	df 90       	pop	r13
    15ce:	cf 90       	pop	r12
    15d0:	bf 90       	pop	r11
    15d2:	af 90       	pop	r10
    15d4:	9f 90       	pop	r9
    15d6:	8f 90       	pop	r8
    15d8:	7f 90       	pop	r7
    15da:	6f 90       	pop	r6
    15dc:	5f 90       	pop	r5
    15de:	4f 90       	pop	r4
    15e0:	08 95       	ret

000015e2 <vTaskDelete>:
    15e2:	ef 92       	push	r14
    15e4:	ff 92       	push	r15
    15e6:	0f 93       	push	r16
    15e8:	1f 93       	push	r17
    15ea:	cf 93       	push	r28
    15ec:	df 93       	push	r29
    15ee:	ec 01       	movw	r28, r24
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
    15f6:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <pxCurrentTCB>
    15fa:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    15fe:	8c 17       	cp	r24, r28
    1600:	9d 07       	cpc	r25, r29
    1602:	11 f0       	breq	.+4      	; 0x1608 <vTaskDelete+0x26>
    1604:	20 97       	sbiw	r28, 0x00	; 0
    1606:	39 f4       	brne	.+14     	; 0x1616 <vTaskDelete+0x34>
    1608:	c0 91 0e 07 	lds	r28, 0x070E	; 0x80070e <pxCurrentTCB>
    160c:	d0 91 0f 07 	lds	r29, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1610:	e1 2c       	mov	r14, r1
    1612:	f1 2c       	mov	r15, r1
    1614:	01 c0       	rjmp	.+2      	; 0x1618 <vTaskDelete+0x36>
    1616:	7e 01       	movw	r14, r28
    1618:	8e 01       	movw	r16, r28
    161a:	0e 5f       	subi	r16, 0xFE	; 254
    161c:	1f 4f       	sbci	r17, 0xFF	; 255
    161e:	c8 01       	movw	r24, r16
    1620:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
    1624:	8c 89       	ldd	r24, Y+20	; 0x14
    1626:	9d 89       	ldd	r25, Y+21	; 0x15
    1628:	89 2b       	or	r24, r25
    162a:	21 f0       	breq	.+8      	; 0x1634 <vTaskDelete+0x52>
    162c:	ce 01       	movw	r24, r28
    162e:	0c 96       	adiw	r24, 0x0c	; 12
    1630:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
    1634:	b8 01       	movw	r22, r16
    1636:	89 eb       	ldi	r24, 0xB9	; 185
    1638:	96 e0       	ldi	r25, 0x06	; 6
    163a:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>
    163e:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxTasksDeleted>
    1642:	8f 5f       	subi	r24, 0xFF	; 255
    1644:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <uxTasksDeleted>
    1648:	80 91 ad 06 	lds	r24, 0x06AD	; 0x8006ad <uxTaskNumber>
    164c:	8f 5f       	subi	r24, 0xFF	; 255
    164e:	80 93 ad 06 	sts	0x06AD, r24	; 0x8006ad <uxTaskNumber>
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <xSchedulerRunning>
    165a:	88 23       	and	r24, r24
    165c:	21 f0       	breq	.+8      	; 0x1666 <vTaskDelete+0x84>
    165e:	ef 28       	or	r14, r15
    1660:	11 f4       	brne	.+4      	; 0x1666 <vTaskDelete+0x84>
    1662:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	1f 91       	pop	r17
    166c:	0f 91       	pop	r16
    166e:	ff 90       	pop	r15
    1670:	ef 90       	pop	r14
    1672:	08 95       	ret

00001674 <vTaskStartScheduler>:
    1674:	af 92       	push	r10
    1676:	bf 92       	push	r11
    1678:	cf 92       	push	r12
    167a:	df 92       	push	r13
    167c:	ef 92       	push	r14
    167e:	ff 92       	push	r15
    1680:	0f 93       	push	r16
    1682:	a1 2c       	mov	r10, r1
    1684:	b1 2c       	mov	r11, r1
    1686:	c1 2c       	mov	r12, r1
    1688:	d1 2c       	mov	r13, r1
    168a:	e1 2c       	mov	r14, r1
    168c:	f1 2c       	mov	r15, r1
    168e:	00 e0       	ldi	r16, 0x00	; 0
    1690:	20 e0       	ldi	r18, 0x00	; 0
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	45 e5       	ldi	r20, 0x55	; 85
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	6f e9       	ldi	r22, 0x9F	; 159
    169a:	70 e0       	ldi	r23, 0x00	; 0
    169c:	88 e2       	ldi	r24, 0x28	; 40
    169e:	9d e0       	ldi	r25, 0x0D	; 13
    16a0:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskGenericCreate>
    16a4:	81 30       	cpi	r24, 0x01	; 1
    16a6:	49 f4       	brne	.+18     	; 0x16ba <vTaskStartScheduler+0x46>
    16a8:	f8 94       	cli
    16aa:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <xSchedulerRunning>
    16ae:	10 92 b6 06 	sts	0x06B6, r1	; 0x8006b6 <xTickCount+0x1>
    16b2:	10 92 b5 06 	sts	0x06B5, r1	; 0x8006b5 <xTickCount>
    16b6:	0e 94 03 03 	call	0x606	; 0x606 <xPortStartScheduler>
    16ba:	0f 91       	pop	r16
    16bc:	ff 90       	pop	r15
    16be:	ef 90       	pop	r14
    16c0:	df 90       	pop	r13
    16c2:	cf 90       	pop	r12
    16c4:	bf 90       	pop	r11
    16c6:	af 90       	pop	r10
    16c8:	08 95       	ret

000016ca <vTaskSuspendAll>:
    16ca:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    16ce:	8f 5f       	subi	r24, 0xFF	; 255
    16d0:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <uxSchedulerSuspended>
    16d4:	08 95       	ret

000016d6 <xTaskGetTickCount>:
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	0f 92       	push	r0
    16dc:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    16e0:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    16e4:	0f 90       	pop	r0
    16e6:	0f be       	out	0x3f, r0	; 63
    16e8:	08 95       	ret

000016ea <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    16ea:	0f 93       	push	r16
    16ec:	1f 93       	push	r17
    16ee:	cf 93       	push	r28
    16f0:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16f2:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    16f6:	81 11       	cpse	r24, r1
    16f8:	b2 c0       	rjmp	.+356    	; 0x185e <vTaskIncrementTick+0x174>
	{
		++xTickCount;
    16fa:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    16fe:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1702:	01 96       	adiw	r24, 0x01	; 1
    1704:	90 93 b6 06 	sts	0x06B6, r25	; 0x8006b6 <xTickCount+0x1>
    1708:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <xTickCount>
		if( xTickCount == ( portTickType ) 0U )
    170c:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1710:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1714:	89 2b       	or	r24, r25
    1716:	99 f5       	brne	.+102    	; 0x177e <vTaskIncrementTick+0x94>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1718:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    171c:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1720:	20 91 cb 06 	lds	r18, 0x06CB	; 0x8006cb <pxOverflowDelayedTaskList>
    1724:	30 91 cc 06 	lds	r19, 0x06CC	; 0x8006cc <pxOverflowDelayedTaskList+0x1>
    1728:	30 93 ce 06 	sts	0x06CE, r19	; 0x8006ce <pxDelayedTaskList+0x1>
    172c:	20 93 cd 06 	sts	0x06CD, r18	; 0x8006cd <pxDelayedTaskList>
			pxOverflowDelayedTaskList = pxTemp;
    1730:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <pxOverflowDelayedTaskList+0x1>
    1734:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <pxOverflowDelayedTaskList>
			xNumOfOverflows++;
    1738:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <xNumOfOverflows>
    173c:	8f 5f       	subi	r24, 0xFF	; 255
    173e:	80 93 ae 06 	sts	0x06AE, r24	; 0x8006ae <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1742:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    1746:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    174a:	80 81       	ld	r24, Z
    174c:	81 11       	cpse	r24, r1
    174e:	07 c0       	rjmp	.+14     	; 0x175e <vTaskIncrementTick+0x74>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1750:	8f ef       	ldi	r24, 0xFF	; 255
    1752:	9f ef       	ldi	r25, 0xFF	; 255
    1754:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    1758:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    175c:	10 c0       	rjmp	.+32     	; 0x177e <vTaskIncrementTick+0x94>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    175e:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    1762:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    1766:	05 80       	ldd	r0, Z+5	; 0x05
    1768:	f6 81       	ldd	r31, Z+6	; 0x06
    176a:	e0 2d       	mov	r30, r0
    176c:	06 80       	ldd	r0, Z+6	; 0x06
    176e:	f7 81       	ldd	r31, Z+7	; 0x07
    1770:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1772:	82 81       	ldd	r24, Z+2	; 0x02
    1774:	93 81       	ldd	r25, Z+3	; 0x03
    1776:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    177a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    177e:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xTickCount>
    1782:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1786:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <xNextTaskUnblockTime>
    178a:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <xNextTaskUnblockTime+0x1>
    178e:	28 17       	cp	r18, r24
    1790:	39 07       	cpc	r19, r25
    1792:	08 f4       	brcc	.+2      	; 0x1796 <vTaskIncrementTick+0xac>
    1794:	69 c0       	rjmp	.+210    	; 0x1868 <vTaskIncrementTick+0x17e>
    1796:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    179a:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    179e:	80 81       	ld	r24, Z
    17a0:	88 23       	and	r24, r24
    17a2:	99 f0       	breq	.+38     	; 0x17ca <vTaskIncrementTick+0xe0>
    17a4:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    17a8:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    17ac:	05 80       	ldd	r0, Z+5	; 0x05
    17ae:	f6 81       	ldd	r31, Z+6	; 0x06
    17b0:	e0 2d       	mov	r30, r0
    17b2:	c6 81       	ldd	r28, Z+6	; 0x06
    17b4:	d7 81       	ldd	r29, Z+7	; 0x07
    17b6:	8a 81       	ldd	r24, Y+2	; 0x02
    17b8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ba:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xTickCount>
    17be:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    17c2:	28 17       	cp	r18, r24
    17c4:	39 07       	cpc	r19, r25
    17c6:	f8 f4       	brcc	.+62     	; 0x1806 <vTaskIncrementTick+0x11c>
    17c8:	19 c0       	rjmp	.+50     	; 0x17fc <vTaskIncrementTick+0x112>
    17ca:	8f ef       	ldi	r24, 0xFF	; 255
    17cc:	9f ef       	ldi	r25, 0xFF	; 255
    17ce:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    17d2:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    17d6:	48 c0       	rjmp	.+144    	; 0x1868 <vTaskIncrementTick+0x17e>
    17d8:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    17dc:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    17e0:	05 80       	ldd	r0, Z+5	; 0x05
    17e2:	f6 81       	ldd	r31, Z+6	; 0x06
    17e4:	e0 2d       	mov	r30, r0
    17e6:	c6 81       	ldd	r28, Z+6	; 0x06
    17e8:	d7 81       	ldd	r29, Z+7	; 0x07
    17ea:	8a 81       	ldd	r24, Y+2	; 0x02
    17ec:	9b 81       	ldd	r25, Y+3	; 0x03
    17ee:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xTickCount>
    17f2:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    17f6:	28 17       	cp	r18, r24
    17f8:	39 07       	cpc	r19, r25
    17fa:	28 f4       	brcc	.+10     	; 0x1806 <vTaskIncrementTick+0x11c>
    17fc:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <xNextTaskUnblockTime+0x1>
    1800:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <xNextTaskUnblockTime>
    1804:	31 c0       	rjmp	.+98     	; 0x1868 <vTaskIncrementTick+0x17e>
    1806:	8e 01       	movw	r16, r28
    1808:	0e 5f       	subi	r16, 0xFE	; 254
    180a:	1f 4f       	sbci	r17, 0xFF	; 255
    180c:	c8 01       	movw	r24, r16
    180e:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
    1812:	8c 89       	ldd	r24, Y+20	; 0x14
    1814:	9d 89       	ldd	r25, Y+21	; 0x15
    1816:	89 2b       	or	r24, r25
    1818:	21 f0       	breq	.+8      	; 0x1822 <vTaskIncrementTick+0x138>
    181a:	ce 01       	movw	r24, r28
    181c:	0c 96       	adiw	r24, 0x0c	; 12
    181e:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
    1822:	8e 89       	ldd	r24, Y+22	; 0x16
    1824:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1828:	98 17       	cp	r25, r24
    182a:	10 f4       	brcc	.+4      	; 0x1830 <vTaskIncrementTick+0x146>
    182c:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <uxTopReadyPriority>
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	9c 01       	movw	r18, r24
    1834:	22 0f       	add	r18, r18
    1836:	33 1f       	adc	r19, r19
    1838:	22 0f       	add	r18, r18
    183a:	33 1f       	adc	r19, r19
    183c:	22 0f       	add	r18, r18
    183e:	33 1f       	adc	r19, r19
    1840:	82 0f       	add	r24, r18
    1842:	93 1f       	adc	r25, r19
    1844:	b8 01       	movw	r22, r16
    1846:	8f 51       	subi	r24, 0x1F	; 31
    1848:	99 4f       	sbci	r25, 0xF9	; 249
    184a:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>
    184e:	e0 91 cd 06 	lds	r30, 0x06CD	; 0x8006cd <pxDelayedTaskList>
    1852:	f0 91 ce 06 	lds	r31, 0x06CE	; 0x8006ce <pxDelayedTaskList+0x1>
    1856:	80 81       	ld	r24, Z
    1858:	81 11       	cpse	r24, r1
    185a:	be cf       	rjmp	.-132    	; 0x17d8 <vTaskIncrementTick+0xee>
    185c:	b6 cf       	rjmp	.-148    	; 0x17ca <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    185e:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <uxMissedTicks>
    1862:	8f 5f       	subi	r24, 0xFF	; 255
    1864:	80 93 b0 06 	sts	0x06B0, r24	; 0x8006b0 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	1f 91       	pop	r17
    186e:	0f 91       	pop	r16
    1870:	08 95       	ret

00001872 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1872:	cf 92       	push	r12
    1874:	df 92       	push	r13
    1876:	ef 92       	push	r14
    1878:	ff 92       	push	r15
    187a:	0f 93       	push	r16
    187c:	1f 93       	push	r17
    187e:	cf 93       	push	r28
    1880:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1888:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    188c:	81 50       	subi	r24, 0x01	; 1
    188e:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1892:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    1896:	81 11       	cpse	r24, r1
    1898:	63 c0       	rjmp	.+198    	; 0x1960 <xTaskResumeAll+0xee>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    189a:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <uxCurrentNumberOfTasks>
    189e:	81 11       	cpse	r24, r1
    18a0:	32 c0       	rjmp	.+100    	; 0x1906 <xTaskResumeAll+0x94>
    18a2:	61 c0       	rjmp	.+194    	; 0x1966 <xTaskResumeAll+0xf4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    18a4:	d7 01       	movw	r26, r14
    18a6:	15 96       	adiw	r26, 0x05	; 5
    18a8:	ed 91       	ld	r30, X+
    18aa:	fc 91       	ld	r31, X
    18ac:	16 97       	sbiw	r26, 0x06	; 6
    18ae:	c6 81       	ldd	r28, Z+6	; 0x06
    18b0:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    18b2:	ce 01       	movw	r24, r28
    18b4:	0c 96       	adiw	r24, 0x0c	; 12
    18b6:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    18ba:	8e 01       	movw	r16, r28
    18bc:	0e 5f       	subi	r16, 0xFE	; 254
    18be:	1f 4f       	sbci	r17, 0xFF	; 255
    18c0:	c8 01       	movw	r24, r16
    18c2:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    18c6:	8e 89       	ldd	r24, Y+22	; 0x16
    18c8:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    18cc:	98 17       	cp	r25, r24
    18ce:	10 f4       	brcc	.+4      	; 0x18d4 <xTaskResumeAll+0x62>
    18d0:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <uxTopReadyPriority>
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	9c 01       	movw	r18, r24
    18d8:	22 0f       	add	r18, r18
    18da:	33 1f       	adc	r19, r19
    18dc:	22 0f       	add	r18, r18
    18de:	33 1f       	adc	r19, r19
    18e0:	22 0f       	add	r18, r18
    18e2:	33 1f       	adc	r19, r19
    18e4:	82 0f       	add	r24, r18
    18e6:	93 1f       	adc	r25, r19
    18e8:	b8 01       	movw	r22, r16
    18ea:	8f 51       	subi	r24, 0x1F	; 31
    18ec:	99 4f       	sbci	r25, 0xF9	; 249
    18ee:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    18f2:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <pxCurrentTCB>
    18f6:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    18fa:	9e 89       	ldd	r25, Y+22	; 0x16
    18fc:	86 89       	ldd	r24, Z+22	; 0x16
    18fe:	98 17       	cp	r25, r24
    1900:	58 f0       	brcs	.+22     	; 0x1918 <xTaskResumeAll+0xa6>
					{
						xYieldRequired = pdTRUE;
    1902:	dc 2c       	mov	r13, r12
    1904:	09 c0       	rjmp	.+18     	; 0x1918 <xTaskResumeAll+0xa6>
    1906:	d1 2c       	mov	r13, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1908:	0f 2e       	mov	r0, r31
    190a:	f2 ec       	ldi	r31, 0xC2	; 194
    190c:	ef 2e       	mov	r14, r31
    190e:	f6 e0       	ldi	r31, 0x06	; 6
    1910:	ff 2e       	mov	r15, r31
    1912:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1914:	cc 24       	eor	r12, r12
    1916:	c3 94       	inc	r12
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1918:	f7 01       	movw	r30, r14
    191a:	80 81       	ld	r24, Z
    191c:	81 11       	cpse	r24, r1
    191e:	c2 cf       	rjmp	.-124    	; 0x18a4 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1920:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <uxMissedTicks>
    1924:	88 23       	and	r24, r24
    1926:	79 f0       	breq	.+30     	; 0x1946 <xTaskResumeAll+0xd4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1928:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <uxMissedTicks>
    192c:	88 23       	and	r24, r24
    192e:	59 f0       	breq	.+22     	; 0x1946 <xTaskResumeAll+0xd4>
					{
						vTaskIncrementTick();
    1930:	0e 94 75 0b 	call	0x16ea	; 0x16ea <vTaskIncrementTick>
						--uxMissedTicks;
    1934:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <uxMissedTicks>
    1938:	81 50       	subi	r24, 0x01	; 1
    193a:	80 93 b0 06 	sts	0x06B0, r24	; 0x8006b0 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    193e:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <uxMissedTicks>
    1942:	81 11       	cpse	r24, r1
    1944:	f5 cf       	rjmp	.-22     	; 0x1930 <xTaskResumeAll+0xbe>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1946:	f1 e0       	ldi	r31, 0x01	; 1
    1948:	df 16       	cp	r13, r31
    194a:	21 f0       	breq	.+8      	; 0x1954 <xTaskResumeAll+0xe2>
    194c:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <xMissedYield>
    1950:	81 30       	cpi	r24, 0x01	; 1
    1952:	41 f4       	brne	.+16     	; 0x1964 <xTaskResumeAll+0xf2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1954:	10 92 af 06 	sts	0x06AF, r1	; 0x8006af <xMissedYield>
					portYIELD_WITHIN_API();
    1958:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	03 c0       	rjmp	.+6      	; 0x1966 <xTaskResumeAll+0xf4>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	01 c0       	rjmp	.+2      	; 0x1966 <xTaskResumeAll+0xf4>
    1964:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	1f 91       	pop	r17
    1970:	0f 91       	pop	r16
    1972:	ff 90       	pop	r15
    1974:	ef 90       	pop	r14
    1976:	df 90       	pop	r13
    1978:	cf 90       	pop	r12
    197a:	08 95       	ret

0000197c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    197c:	0f 93       	push	r16
    197e:	1f 93       	push	r17
    1980:	cf 93       	push	r28
    1982:	df 93       	push	r29
    1984:	8c 01       	movw	r16, r24
    1986:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1988:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    198c:	f8 01       	movw	r30, r16
    198e:	80 81       	ld	r24, Z
    1990:	91 81       	ldd	r25, Z+1	; 0x01
    1992:	c8 0f       	add	r28, r24
    1994:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    1996:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xTickCount>
    199a:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    199e:	28 17       	cp	r18, r24
    19a0:	39 07       	cpc	r19, r25
    19a2:	68 f4       	brcc	.+26     	; 0x19be <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    19a4:	c8 17       	cp	r28, r24
    19a6:	d9 07       	cpc	r29, r25
    19a8:	50 f5       	brcc	.+84     	; 0x19fe <vTaskDelayUntil+0x82>
    19aa:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    19ae:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    19b2:	d1 83       	std	Z+1, r29	; 0x01
    19b4:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    19b6:	8c 17       	cp	r24, r28
    19b8:	9d 07       	cpc	r25, r29
    19ba:	b0 f4       	brcc	.+44     	; 0x19e8 <vTaskDelayUntil+0x6c>
    19bc:	0b c0       	rjmp	.+22     	; 0x19d4 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    19be:	c8 17       	cp	r28, r24
    19c0:	d9 07       	cpc	r29, r25
    19c2:	c8 f0       	brcs	.+50     	; 0x19f6 <vTaskDelayUntil+0x7a>
    19c4:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    19c8:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    19cc:	8c 17       	cp	r24, r28
    19ce:	9d 07       	cpc	r25, r29
    19d0:	90 f0       	brcs	.+36     	; 0x19f6 <vTaskDelayUntil+0x7a>
    19d2:	15 c0       	rjmp	.+42     	; 0x19fe <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    19d4:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <pxCurrentTCB>
    19d8:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    19dc:	02 96       	adiw	r24, 0x02	; 2
    19de:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    19e2:	ce 01       	movw	r24, r28
    19e4:	0e 94 b1 09 	call	0x1362	; 0x1362 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    19e8:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    19ec:	81 11       	cpse	r24, r1
    19ee:	0b c0       	rjmp	.+22     	; 0x1a06 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    19f0:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
		}
	}
    19f4:	08 c0       	rjmp	.+16     	; 0x1a06 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    19f6:	f8 01       	movw	r30, r16
    19f8:	d1 83       	std	Z+1, r29	; 0x01
    19fa:	c0 83       	st	Z, r28
    19fc:	eb cf       	rjmp	.-42     	; 0x19d4 <vTaskDelayUntil+0x58>
    19fe:	f8 01       	movw	r30, r16
    1a00:	d1 83       	std	Z+1, r29	; 0x01
    1a02:	c0 83       	st	Z, r28
    1a04:	f1 cf       	rjmp	.-30     	; 0x19e8 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1a06:	df 91       	pop	r29
    1a08:	cf 91       	pop	r28
    1a0a:	1f 91       	pop	r17
    1a0c:	0f 91       	pop	r16
    1a0e:	08 95       	ret

00001a10 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1a16:	89 2b       	or	r24, r25
    1a18:	b1 f0       	breq	.+44     	; 0x1a46 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1a1a:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1a1e:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1a22:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1a26:	c8 0f       	add	r28, r24
    1a28:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1a2a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <pxCurrentTCB>
    1a2e:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1a32:	02 96       	adiw	r24, 0x02	; 2
    1a34:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a38:	ce 01       	movw	r24, r28
    1a3a:	0e 94 b1 09 	call	0x1362	; 0x1362 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1a3e:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a42:	81 11       	cpse	r24, r1
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1a46:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
		}
	}
    1a4a:	df 91       	pop	r29
    1a4c:	cf 91       	pop	r28
    1a4e:	08 95       	ret

00001a50 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a50:	09 eb       	ldi	r16, 0xB9	; 185
    1a52:	16 e0       	ldi	r17, 0x06	; 6
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1a54:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxTasksDeleted>
    1a58:	88 23       	and	r24, r24
    1a5a:	49 f1       	breq	.+82     	; 0x1aae <prvIdleTask+0x5e>
		{
			vTaskSuspendAll();
    1a5c:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1a60:	d8 01       	movw	r26, r16
    1a62:	cc 91       	ld	r28, X
			xTaskResumeAll();
    1a64:	0e 94 39 0c 	call	0x1872	; 0x1872 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1a68:	cc 23       	and	r28, r28
    1a6a:	09 f1       	breq	.+66     	; 0x1aae <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1a6c:	0f b6       	in	r0, 0x3f	; 63
    1a6e:	f8 94       	cli
    1a70:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1a72:	d8 01       	movw	r26, r16
    1a74:	15 96       	adiw	r26, 0x05	; 5
    1a76:	ed 91       	ld	r30, X+
    1a78:	fc 91       	ld	r31, X
    1a7a:	16 97       	sbiw	r26, 0x06	; 6
    1a7c:	c6 81       	ldd	r28, Z+6	; 0x06
    1a7e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1a80:	ce 01       	movw	r24, r28
    1a82:	02 96       	adiw	r24, 0x02	; 2
    1a84:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
					--uxCurrentNumberOfTasks;
    1a88:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <uxCurrentNumberOfTasks>
    1a8c:	81 50       	subi	r24, 0x01	; 1
    1a8e:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1a92:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <uxTasksDeleted>
    1a96:	81 50       	subi	r24, 0x01	; 1
    1a98:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1a9c:	0f 90       	pop	r0
    1a9e:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1aa0:	8f 89       	ldd	r24, Y+23	; 0x17
    1aa2:	98 8d       	ldd	r25, Y+24	; 0x18
    1aa4:	0e 94 06 01 	call	0x20c	; 0x20c <vPortFree>
		vPortFree( pxTCB );
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	0e 94 06 01 	call	0x20c	; 0x20c <vPortFree>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    1aae:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
    1ab2:	d0 cf       	rjmp	.-96     	; 0x1a54 <prvIdleTask+0x4>

00001ab4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1ab4:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    1ab8:	81 11       	cpse	r24, r1
    1aba:	13 c0       	rjmp	.+38     	; 0x1ae2 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1abc:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	fc 01       	movw	r30, r24
    1ac4:	ee 0f       	add	r30, r30
    1ac6:	ff 1f       	adc	r31, r31
    1ac8:	ee 0f       	add	r30, r30
    1aca:	ff 1f       	adc	r31, r31
    1acc:	ee 0f       	add	r30, r30
    1ace:	ff 1f       	adc	r31, r31
    1ad0:	8e 0f       	add	r24, r30
    1ad2:	9f 1f       	adc	r25, r31
    1ad4:	fc 01       	movw	r30, r24
    1ad6:	ef 51       	subi	r30, 0x1F	; 31
    1ad8:	f9 4f       	sbci	r31, 0xF9	; 249
    1ada:	80 81       	ld	r24, Z
    1adc:	88 23       	and	r24, r24
    1ade:	29 f0       	breq	.+10     	; 0x1aea <vTaskSwitchContext+0x36>
    1ae0:	1b c0       	rjmp	.+54     	; 0x1b18 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <xMissedYield>
    1ae8:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1aea:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1aee:	81 50       	subi	r24, 0x01	; 1
    1af0:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1af4:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	fc 01       	movw	r30, r24
    1afc:	ee 0f       	add	r30, r30
    1afe:	ff 1f       	adc	r31, r31
    1b00:	ee 0f       	add	r30, r30
    1b02:	ff 1f       	adc	r31, r31
    1b04:	ee 0f       	add	r30, r30
    1b06:	ff 1f       	adc	r31, r31
    1b08:	8e 0f       	add	r24, r30
    1b0a:	9f 1f       	adc	r25, r31
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	ef 51       	subi	r30, 0x1F	; 31
    1b10:	f9 4f       	sbci	r31, 0xF9	; 249
    1b12:	80 81       	ld	r24, Z
    1b14:	88 23       	and	r24, r24
    1b16:	49 f3       	breq	.-46     	; 0x1aea <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1b18:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	9c 01       	movw	r18, r24
    1b20:	22 0f       	add	r18, r18
    1b22:	33 1f       	adc	r19, r19
    1b24:	22 0f       	add	r18, r18
    1b26:	33 1f       	adc	r19, r19
    1b28:	22 0f       	add	r18, r18
    1b2a:	33 1f       	adc	r19, r19
    1b2c:	28 0f       	add	r18, r24
    1b2e:	39 1f       	adc	r19, r25
    1b30:	d9 01       	movw	r26, r18
    1b32:	af 51       	subi	r26, 0x1F	; 31
    1b34:	b9 4f       	sbci	r27, 0xF9	; 249
    1b36:	11 96       	adiw	r26, 0x01	; 1
    1b38:	ed 91       	ld	r30, X+
    1b3a:	fc 91       	ld	r31, X
    1b3c:	12 97       	sbiw	r26, 0x02	; 2
    1b3e:	02 80       	ldd	r0, Z+2	; 0x02
    1b40:	f3 81       	ldd	r31, Z+3	; 0x03
    1b42:	e0 2d       	mov	r30, r0
    1b44:	12 96       	adiw	r26, 0x02	; 2
    1b46:	fc 93       	st	X, r31
    1b48:	ee 93       	st	-X, r30
    1b4a:	11 97       	sbiw	r26, 0x01	; 1
    1b4c:	2c 51       	subi	r18, 0x1C	; 28
    1b4e:	39 4f       	sbci	r19, 0xF9	; 249
    1b50:	e2 17       	cp	r30, r18
    1b52:	f3 07       	cpc	r31, r19
    1b54:	29 f4       	brne	.+10     	; 0x1b60 <vTaskSwitchContext+0xac>
    1b56:	22 81       	ldd	r18, Z+2	; 0x02
    1b58:	33 81       	ldd	r19, Z+3	; 0x03
    1b5a:	fd 01       	movw	r30, r26
    1b5c:	32 83       	std	Z+2, r19	; 0x02
    1b5e:	21 83       	std	Z+1, r18	; 0x01
    1b60:	fc 01       	movw	r30, r24
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ee 0f       	add	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	ee 0f       	add	r30, r30
    1b6c:	ff 1f       	adc	r31, r31
    1b6e:	8e 0f       	add	r24, r30
    1b70:	9f 1f       	adc	r25, r31
    1b72:	fc 01       	movw	r30, r24
    1b74:	ef 51       	subi	r30, 0x1F	; 31
    1b76:	f9 4f       	sbci	r31, 0xF9	; 249
    1b78:	01 80       	ldd	r0, Z+1	; 0x01
    1b7a:	f2 81       	ldd	r31, Z+2	; 0x02
    1b7c:	e0 2d       	mov	r30, r0
    1b7e:	86 81       	ldd	r24, Z+6	; 0x06
    1b80:	97 81       	ldd	r25, Z+7	; 0x07
    1b82:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <pxCurrentTCB+0x1>
    1b86:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <pxCurrentTCB>
    1b8a:	08 95       	ret

00001b8c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1b8c:	cf 93       	push	r28
    1b8e:	df 93       	push	r29
    1b90:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1b92:	60 91 0e 07 	lds	r22, 0x070E	; 0x80070e <pxCurrentTCB>
    1b96:	70 91 0f 07 	lds	r23, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1b9a:	64 5f       	subi	r22, 0xF4	; 244
    1b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b9e:	0e 94 36 02 	call	0x46c	; 0x46c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ba2:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <pxCurrentTCB>
    1ba6:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
    1baa:	02 96       	adiw	r24, 0x02	; 2
    1bac:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1bb0:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1bb4:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1bb8:	8c 0f       	add	r24, r28
    1bba:	9d 1f       	adc	r25, r29
    1bbc:	0e 94 b1 09 	call	0x1362	; 0x1362 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1bc0:	df 91       	pop	r29
    1bc2:	cf 91       	pop	r28
    1bc4:	08 95       	ret

00001bc6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1bc6:	0f 93       	push	r16
    1bc8:	1f 93       	push	r17
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1bce:	dc 01       	movw	r26, r24
    1bd0:	15 96       	adiw	r26, 0x05	; 5
    1bd2:	ed 91       	ld	r30, X+
    1bd4:	fc 91       	ld	r31, X
    1bd6:	16 97       	sbiw	r26, 0x06	; 6
    1bd8:	c6 81       	ldd	r28, Z+6	; 0x06
    1bda:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1bdc:	8e 01       	movw	r16, r28
    1bde:	04 5f       	subi	r16, 0xF4	; 244
    1be0:	1f 4f       	sbci	r17, 0xFF	; 255
    1be2:	c8 01       	movw	r24, r16
    1be4:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1be8:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <uxSchedulerSuspended>
    1bec:	81 11       	cpse	r24, r1
    1bee:	1c c0       	rjmp	.+56     	; 0x1c28 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1bf0:	0a 50       	subi	r16, 0x0A	; 10
    1bf2:	11 09       	sbc	r17, r1
    1bf4:	c8 01       	movw	r24, r16
    1bf6:	0e 94 71 02 	call	0x4e2	; 0x4e2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1bfa:	8e 89       	ldd	r24, Y+22	; 0x16
    1bfc:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <uxTopReadyPriority>
    1c00:	98 17       	cp	r25, r24
    1c02:	10 f4       	brcc	.+4      	; 0x1c08 <xTaskRemoveFromEventList+0x42>
    1c04:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <uxTopReadyPriority>
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	9c 01       	movw	r18, r24
    1c0c:	22 0f       	add	r18, r18
    1c0e:	33 1f       	adc	r19, r19
    1c10:	22 0f       	add	r18, r18
    1c12:	33 1f       	adc	r19, r19
    1c14:	22 0f       	add	r18, r18
    1c16:	33 1f       	adc	r19, r19
    1c18:	82 0f       	add	r24, r18
    1c1a:	93 1f       	adc	r25, r19
    1c1c:	b8 01       	movw	r22, r16
    1c1e:	8f 51       	subi	r24, 0x1F	; 31
    1c20:	99 4f       	sbci	r25, 0xF9	; 249
    1c22:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>
    1c26:	05 c0       	rjmp	.+10     	; 0x1c32 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1c28:	b8 01       	movw	r22, r16
    1c2a:	82 ec       	ldi	r24, 0xC2	; 194
    1c2c:	96 e0       	ldi	r25, 0x06	; 6
    1c2e:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c32:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <pxCurrentTCB>
    1c36:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	2e 89       	ldd	r18, Y+22	; 0x16
    1c3e:	96 89       	ldd	r25, Z+22	; 0x16
    1c40:	29 17       	cp	r18, r25
    1c42:	08 f4       	brcc	.+2      	; 0x1c46 <xTaskRemoveFromEventList+0x80>
    1c44:	80 e0       	ldi	r24, 0x00	; 0
}
    1c46:	df 91       	pop	r29
    1c48:	cf 91       	pop	r28
    1c4a:	1f 91       	pop	r17
    1c4c:	0f 91       	pop	r16
    1c4e:	08 95       	ret

00001c50 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1c50:	20 91 ae 06 	lds	r18, 0x06AE	; 0x8006ae <xNumOfOverflows>
    1c54:	fc 01       	movw	r30, r24
    1c56:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1c58:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xTickCount>
    1c5c:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1c60:	32 83       	std	Z+2, r19	; 0x02
    1c62:	21 83       	std	Z+1, r18	; 0x01
    1c64:	08 95       	ret

00001c66 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1c66:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1c68:	0f b6       	in	r0, 0x3f	; 63
    1c6a:	f8 94       	cli
    1c6c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1c6e:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <xNumOfOverflows>
    1c72:	90 81       	ld	r25, Z
    1c74:	98 17       	cp	r25, r24
    1c76:	49 f0       	breq	.+18     	; 0x1c8a <xTaskCheckForTimeOut+0x24>
    1c78:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1c7c:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1c80:	21 81       	ldd	r18, Z+1	; 0x01
    1c82:	32 81       	ldd	r19, Z+2	; 0x02
    1c84:	82 17       	cp	r24, r18
    1c86:	93 07       	cpc	r25, r19
    1c88:	f8 f4       	brcc	.+62     	; 0x1cc8 <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1c8a:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xTickCount>
    1c8e:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1c92:	41 81       	ldd	r20, Z+1	; 0x01
    1c94:	52 81       	ldd	r21, Z+2	; 0x02
    1c96:	db 01       	movw	r26, r22
    1c98:	2d 91       	ld	r18, X+
    1c9a:	3c 91       	ld	r19, X
    1c9c:	11 97       	sbiw	r26, 0x01	; 1
    1c9e:	84 1b       	sub	r24, r20
    1ca0:	95 0b       	sbc	r25, r21
    1ca2:	82 17       	cp	r24, r18
    1ca4:	93 07       	cpc	r25, r19
    1ca6:	90 f4       	brcc	.+36     	; 0x1ccc <xTaskCheckForTimeOut+0x66>
    1ca8:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1caa:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <xTickCount>
    1cae:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <xTickCount+0x1>
    1cb2:	bf 01       	movw	r22, r30
    1cb4:	64 1b       	sub	r22, r20
    1cb6:	75 0b       	sbc	r23, r21
    1cb8:	26 1b       	sub	r18, r22
    1cba:	37 0b       	sbc	r19, r23
    1cbc:	2d 93       	st	X+, r18
    1cbe:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1cc0:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	03 c0       	rjmp	.+6      	; 0x1cce <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	01 c0       	rjmp	.+2      	; 0x1cce <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1cce:	0f 90       	pop	r0
    1cd0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1cd2:	08 95       	ret

00001cd4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <xMissedYield>
    1cda:	08 95       	ret

00001cdc <__divmodhi4>:
    1cdc:	97 fb       	bst	r25, 7
    1cde:	07 2e       	mov	r0, r23
    1ce0:	16 f4       	brtc	.+4      	; 0x1ce6 <__divmodhi4+0xa>
    1ce2:	00 94       	com	r0
    1ce4:	07 d0       	rcall	.+14     	; 0x1cf4 <__divmodhi4_neg1>
    1ce6:	77 fd       	sbrc	r23, 7
    1ce8:	09 d0       	rcall	.+18     	; 0x1cfc <__divmodhi4_neg2>
    1cea:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <__udivmodhi4>
    1cee:	07 fc       	sbrc	r0, 7
    1cf0:	05 d0       	rcall	.+10     	; 0x1cfc <__divmodhi4_neg2>
    1cf2:	3e f4       	brtc	.+14     	; 0x1d02 <__divmodhi4_exit>

00001cf4 <__divmodhi4_neg1>:
    1cf4:	90 95       	com	r25
    1cf6:	81 95       	neg	r24
    1cf8:	9f 4f       	sbci	r25, 0xFF	; 255
    1cfa:	08 95       	ret

00001cfc <__divmodhi4_neg2>:
    1cfc:	70 95       	com	r23
    1cfe:	61 95       	neg	r22
    1d00:	7f 4f       	sbci	r23, 0xFF	; 255

00001d02 <__divmodhi4_exit>:
    1d02:	08 95       	ret

00001d04 <__tablejump2__>:
    1d04:	ee 0f       	add	r30, r30
    1d06:	ff 1f       	adc	r31, r31
    1d08:	05 90       	lpm	r0, Z+
    1d0a:	f4 91       	lpm	r31, Z
    1d0c:	e0 2d       	mov	r30, r0
    1d0e:	09 94       	ijmp

00001d10 <__udivmodhi4>:
    1d10:	aa 1b       	sub	r26, r26
    1d12:	bb 1b       	sub	r27, r27
    1d14:	51 e1       	ldi	r21, 0x11	; 17
    1d16:	07 c0       	rjmp	.+14     	; 0x1d26 <__udivmodhi4_ep>

00001d18 <__udivmodhi4_loop>:
    1d18:	aa 1f       	adc	r26, r26
    1d1a:	bb 1f       	adc	r27, r27
    1d1c:	a6 17       	cp	r26, r22
    1d1e:	b7 07       	cpc	r27, r23
    1d20:	10 f0       	brcs	.+4      	; 0x1d26 <__udivmodhi4_ep>
    1d22:	a6 1b       	sub	r26, r22
    1d24:	b7 0b       	sbc	r27, r23

00001d26 <__udivmodhi4_ep>:
    1d26:	88 1f       	adc	r24, r24
    1d28:	99 1f       	adc	r25, r25
    1d2a:	5a 95       	dec	r21
    1d2c:	a9 f7       	brne	.-22     	; 0x1d18 <__udivmodhi4_loop>
    1d2e:	80 95       	com	r24
    1d30:	90 95       	com	r25
    1d32:	bc 01       	movw	r22, r24
    1d34:	cd 01       	movw	r24, r26
    1d36:	08 95       	ret

00001d38 <atoi>:
    1d38:	fc 01       	movw	r30, r24
    1d3a:	88 27       	eor	r24, r24
    1d3c:	99 27       	eor	r25, r25
    1d3e:	e8 94       	clt
    1d40:	21 91       	ld	r18, Z+
    1d42:	20 32       	cpi	r18, 0x20	; 32
    1d44:	e9 f3       	breq	.-6      	; 0x1d40 <atoi+0x8>
    1d46:	29 30       	cpi	r18, 0x09	; 9
    1d48:	10 f0       	brcs	.+4      	; 0x1d4e <atoi+0x16>
    1d4a:	2e 30       	cpi	r18, 0x0E	; 14
    1d4c:	c8 f3       	brcs	.-14     	; 0x1d40 <atoi+0x8>
    1d4e:	2b 32       	cpi	r18, 0x2B	; 43
    1d50:	41 f0       	breq	.+16     	; 0x1d62 <atoi+0x2a>
    1d52:	2d 32       	cpi	r18, 0x2D	; 45
    1d54:	39 f4       	brne	.+14     	; 0x1d64 <atoi+0x2c>
    1d56:	68 94       	set
    1d58:	04 c0       	rjmp	.+8      	; 0x1d62 <atoi+0x2a>
    1d5a:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <__mulhi_const_10>
    1d5e:	82 0f       	add	r24, r18
    1d60:	91 1d       	adc	r25, r1
    1d62:	21 91       	ld	r18, Z+
    1d64:	20 53       	subi	r18, 0x30	; 48
    1d66:	2a 30       	cpi	r18, 0x0A	; 10
    1d68:	c0 f3       	brcs	.-16     	; 0x1d5a <atoi+0x22>
    1d6a:	1e f4       	brtc	.+6      	; 0x1d72 <atoi+0x3a>
    1d6c:	90 95       	com	r25
    1d6e:	81 95       	neg	r24
    1d70:	9f 4f       	sbci	r25, 0xFF	; 255
    1d72:	08 95       	ret

00001d74 <memcpy>:
    1d74:	fb 01       	movw	r30, r22
    1d76:	dc 01       	movw	r26, r24
    1d78:	02 c0       	rjmp	.+4      	; 0x1d7e <memcpy+0xa>
    1d7a:	01 90       	ld	r0, Z+
    1d7c:	0d 92       	st	X+, r0
    1d7e:	41 50       	subi	r20, 0x01	; 1
    1d80:	50 40       	sbci	r21, 0x00	; 0
    1d82:	d8 f7       	brcc	.-10     	; 0x1d7a <memcpy+0x6>
    1d84:	08 95       	ret

00001d86 <memset>:
    1d86:	dc 01       	movw	r26, r24
    1d88:	01 c0       	rjmp	.+2      	; 0x1d8c <memset+0x6>
    1d8a:	6d 93       	st	X+, r22
    1d8c:	41 50       	subi	r20, 0x01	; 1
    1d8e:	50 40       	sbci	r21, 0x00	; 0
    1d90:	e0 f7       	brcc	.-8      	; 0x1d8a <memset+0x4>
    1d92:	08 95       	ret

00001d94 <strncpy>:
    1d94:	fb 01       	movw	r30, r22
    1d96:	dc 01       	movw	r26, r24
    1d98:	41 50       	subi	r20, 0x01	; 1
    1d9a:	50 40       	sbci	r21, 0x00	; 0
    1d9c:	48 f0       	brcs	.+18     	; 0x1db0 <strncpy+0x1c>
    1d9e:	01 90       	ld	r0, Z+
    1da0:	0d 92       	st	X+, r0
    1da2:	00 20       	and	r0, r0
    1da4:	c9 f7       	brne	.-14     	; 0x1d98 <strncpy+0x4>
    1da6:	01 c0       	rjmp	.+2      	; 0x1daa <strncpy+0x16>
    1da8:	1d 92       	st	X+, r1
    1daa:	41 50       	subi	r20, 0x01	; 1
    1dac:	50 40       	sbci	r21, 0x00	; 0
    1dae:	e0 f7       	brcc	.-8      	; 0x1da8 <strncpy+0x14>
    1db0:	08 95       	ret

00001db2 <__mulhi_const_10>:
    1db2:	7a e0       	ldi	r23, 0x0A	; 10
    1db4:	97 9f       	mul	r25, r23
    1db6:	90 2d       	mov	r25, r0
    1db8:	87 9f       	mul	r24, r23
    1dba:	80 2d       	mov	r24, r0
    1dbc:	91 0d       	add	r25, r1
    1dbe:	11 24       	eor	r1, r1
    1dc0:	08 95       	ret

00001dc2 <sprintf>:
    1dc2:	ae e0       	ldi	r26, 0x0E	; 14
    1dc4:	b0 e0       	ldi	r27, 0x00	; 0
    1dc6:	e7 ee       	ldi	r30, 0xE7	; 231
    1dc8:	fe e0       	ldi	r31, 0x0E	; 14
    1dca:	0c 94 a2 11 	jmp	0x2344	; 0x2344 <__prologue_saves__+0x1c>
    1dce:	0d 89       	ldd	r16, Y+21	; 0x15
    1dd0:	1e 89       	ldd	r17, Y+22	; 0x16
    1dd2:	86 e0       	ldi	r24, 0x06	; 6
    1dd4:	8c 83       	std	Y+4, r24	; 0x04
    1dd6:	1a 83       	std	Y+2, r17	; 0x02
    1dd8:	09 83       	std	Y+1, r16	; 0x01
    1dda:	8f ef       	ldi	r24, 0xFF	; 255
    1ddc:	9f e7       	ldi	r25, 0x7F	; 127
    1dde:	9e 83       	std	Y+6, r25	; 0x06
    1de0:	8d 83       	std	Y+5, r24	; 0x05
    1de2:	ae 01       	movw	r20, r28
    1de4:	47 5e       	subi	r20, 0xE7	; 231
    1de6:	5f 4f       	sbci	r21, 0xFF	; 255
    1de8:	6f 89       	ldd	r22, Y+23	; 0x17
    1dea:	78 8d       	ldd	r23, Y+24	; 0x18
    1dec:	ce 01       	movw	r24, r28
    1dee:	01 96       	adiw	r24, 0x01	; 1
    1df0:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <vfprintf>
    1df4:	ef 81       	ldd	r30, Y+7	; 0x07
    1df6:	f8 85       	ldd	r31, Y+8	; 0x08
    1df8:	e0 0f       	add	r30, r16
    1dfa:	f1 1f       	adc	r31, r17
    1dfc:	10 82       	st	Z, r1
    1dfe:	2e 96       	adiw	r28, 0x0e	; 14
    1e00:	e4 e0       	ldi	r30, 0x04	; 4
    1e02:	0c 94 be 11 	jmp	0x237c	; 0x237c <__epilogue_restores__+0x1c>

00001e06 <vfprintf>:
    1e06:	ab e0       	ldi	r26, 0x0B	; 11
    1e08:	b0 e0       	ldi	r27, 0x00	; 0
    1e0a:	e9 e0       	ldi	r30, 0x09	; 9
    1e0c:	ff e0       	ldi	r31, 0x0F	; 15
    1e0e:	0c 94 94 11 	jmp	0x2328	; 0x2328 <__prologue_saves__>
    1e12:	6c 01       	movw	r12, r24
    1e14:	7b 01       	movw	r14, r22
    1e16:	8a 01       	movw	r16, r20
    1e18:	fc 01       	movw	r30, r24
    1e1a:	17 82       	std	Z+7, r1	; 0x07
    1e1c:	16 82       	std	Z+6, r1	; 0x06
    1e1e:	83 81       	ldd	r24, Z+3	; 0x03
    1e20:	81 ff       	sbrs	r24, 1
    1e22:	cc c1       	rjmp	.+920    	; 0x21bc <vfprintf+0x3b6>
    1e24:	ce 01       	movw	r24, r28
    1e26:	01 96       	adiw	r24, 0x01	; 1
    1e28:	3c 01       	movw	r6, r24
    1e2a:	f6 01       	movw	r30, r12
    1e2c:	93 81       	ldd	r25, Z+3	; 0x03
    1e2e:	f7 01       	movw	r30, r14
    1e30:	93 fd       	sbrc	r25, 3
    1e32:	85 91       	lpm	r24, Z+
    1e34:	93 ff       	sbrs	r25, 3
    1e36:	81 91       	ld	r24, Z+
    1e38:	7f 01       	movw	r14, r30
    1e3a:	88 23       	and	r24, r24
    1e3c:	09 f4       	brne	.+2      	; 0x1e40 <vfprintf+0x3a>
    1e3e:	ba c1       	rjmp	.+884    	; 0x21b4 <vfprintf+0x3ae>
    1e40:	85 32       	cpi	r24, 0x25	; 37
    1e42:	39 f4       	brne	.+14     	; 0x1e52 <vfprintf+0x4c>
    1e44:	93 fd       	sbrc	r25, 3
    1e46:	85 91       	lpm	r24, Z+
    1e48:	93 ff       	sbrs	r25, 3
    1e4a:	81 91       	ld	r24, Z+
    1e4c:	7f 01       	movw	r14, r30
    1e4e:	85 32       	cpi	r24, 0x25	; 37
    1e50:	29 f4       	brne	.+10     	; 0x1e5c <vfprintf+0x56>
    1e52:	b6 01       	movw	r22, r12
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    1e5a:	e7 cf       	rjmp	.-50     	; 0x1e2a <vfprintf+0x24>
    1e5c:	91 2c       	mov	r9, r1
    1e5e:	21 2c       	mov	r2, r1
    1e60:	31 2c       	mov	r3, r1
    1e62:	ff e1       	ldi	r31, 0x1F	; 31
    1e64:	f3 15       	cp	r31, r3
    1e66:	d8 f0       	brcs	.+54     	; 0x1e9e <vfprintf+0x98>
    1e68:	8b 32       	cpi	r24, 0x2B	; 43
    1e6a:	79 f0       	breq	.+30     	; 0x1e8a <vfprintf+0x84>
    1e6c:	38 f4       	brcc	.+14     	; 0x1e7c <vfprintf+0x76>
    1e6e:	80 32       	cpi	r24, 0x20	; 32
    1e70:	79 f0       	breq	.+30     	; 0x1e90 <vfprintf+0x8a>
    1e72:	83 32       	cpi	r24, 0x23	; 35
    1e74:	a1 f4       	brne	.+40     	; 0x1e9e <vfprintf+0x98>
    1e76:	23 2d       	mov	r18, r3
    1e78:	20 61       	ori	r18, 0x10	; 16
    1e7a:	1d c0       	rjmp	.+58     	; 0x1eb6 <vfprintf+0xb0>
    1e7c:	8d 32       	cpi	r24, 0x2D	; 45
    1e7e:	61 f0       	breq	.+24     	; 0x1e98 <vfprintf+0x92>
    1e80:	80 33       	cpi	r24, 0x30	; 48
    1e82:	69 f4       	brne	.+26     	; 0x1e9e <vfprintf+0x98>
    1e84:	23 2d       	mov	r18, r3
    1e86:	21 60       	ori	r18, 0x01	; 1
    1e88:	16 c0       	rjmp	.+44     	; 0x1eb6 <vfprintf+0xb0>
    1e8a:	83 2d       	mov	r24, r3
    1e8c:	82 60       	ori	r24, 0x02	; 2
    1e8e:	38 2e       	mov	r3, r24
    1e90:	e3 2d       	mov	r30, r3
    1e92:	e4 60       	ori	r30, 0x04	; 4
    1e94:	3e 2e       	mov	r3, r30
    1e96:	2a c0       	rjmp	.+84     	; 0x1eec <vfprintf+0xe6>
    1e98:	f3 2d       	mov	r31, r3
    1e9a:	f8 60       	ori	r31, 0x08	; 8
    1e9c:	1d c0       	rjmp	.+58     	; 0x1ed8 <vfprintf+0xd2>
    1e9e:	37 fc       	sbrc	r3, 7
    1ea0:	2d c0       	rjmp	.+90     	; 0x1efc <vfprintf+0xf6>
    1ea2:	20 ed       	ldi	r18, 0xD0	; 208
    1ea4:	28 0f       	add	r18, r24
    1ea6:	2a 30       	cpi	r18, 0x0A	; 10
    1ea8:	40 f0       	brcs	.+16     	; 0x1eba <vfprintf+0xb4>
    1eaa:	8e 32       	cpi	r24, 0x2E	; 46
    1eac:	b9 f4       	brne	.+46     	; 0x1edc <vfprintf+0xd6>
    1eae:	36 fc       	sbrc	r3, 6
    1eb0:	81 c1       	rjmp	.+770    	; 0x21b4 <vfprintf+0x3ae>
    1eb2:	23 2d       	mov	r18, r3
    1eb4:	20 64       	ori	r18, 0x40	; 64
    1eb6:	32 2e       	mov	r3, r18
    1eb8:	19 c0       	rjmp	.+50     	; 0x1eec <vfprintf+0xe6>
    1eba:	36 fe       	sbrs	r3, 6
    1ebc:	06 c0       	rjmp	.+12     	; 0x1eca <vfprintf+0xc4>
    1ebe:	8a e0       	ldi	r24, 0x0A	; 10
    1ec0:	98 9e       	mul	r9, r24
    1ec2:	20 0d       	add	r18, r0
    1ec4:	11 24       	eor	r1, r1
    1ec6:	92 2e       	mov	r9, r18
    1ec8:	11 c0       	rjmp	.+34     	; 0x1eec <vfprintf+0xe6>
    1eca:	ea e0       	ldi	r30, 0x0A	; 10
    1ecc:	2e 9e       	mul	r2, r30
    1ece:	20 0d       	add	r18, r0
    1ed0:	11 24       	eor	r1, r1
    1ed2:	22 2e       	mov	r2, r18
    1ed4:	f3 2d       	mov	r31, r3
    1ed6:	f0 62       	ori	r31, 0x20	; 32
    1ed8:	3f 2e       	mov	r3, r31
    1eda:	08 c0       	rjmp	.+16     	; 0x1eec <vfprintf+0xe6>
    1edc:	8c 36       	cpi	r24, 0x6C	; 108
    1ede:	21 f4       	brne	.+8      	; 0x1ee8 <vfprintf+0xe2>
    1ee0:	83 2d       	mov	r24, r3
    1ee2:	80 68       	ori	r24, 0x80	; 128
    1ee4:	38 2e       	mov	r3, r24
    1ee6:	02 c0       	rjmp	.+4      	; 0x1eec <vfprintf+0xe6>
    1ee8:	88 36       	cpi	r24, 0x68	; 104
    1eea:	41 f4       	brne	.+16     	; 0x1efc <vfprintf+0xf6>
    1eec:	f7 01       	movw	r30, r14
    1eee:	93 fd       	sbrc	r25, 3
    1ef0:	85 91       	lpm	r24, Z+
    1ef2:	93 ff       	sbrs	r25, 3
    1ef4:	81 91       	ld	r24, Z+
    1ef6:	7f 01       	movw	r14, r30
    1ef8:	81 11       	cpse	r24, r1
    1efa:	b3 cf       	rjmp	.-154    	; 0x1e62 <vfprintf+0x5c>
    1efc:	98 2f       	mov	r25, r24
    1efe:	9f 7d       	andi	r25, 0xDF	; 223
    1f00:	95 54       	subi	r25, 0x45	; 69
    1f02:	93 30       	cpi	r25, 0x03	; 3
    1f04:	28 f4       	brcc	.+10     	; 0x1f10 <vfprintf+0x10a>
    1f06:	0c 5f       	subi	r16, 0xFC	; 252
    1f08:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0a:	9f e3       	ldi	r25, 0x3F	; 63
    1f0c:	99 83       	std	Y+1, r25	; 0x01
    1f0e:	0d c0       	rjmp	.+26     	; 0x1f2a <vfprintf+0x124>
    1f10:	83 36       	cpi	r24, 0x63	; 99
    1f12:	31 f0       	breq	.+12     	; 0x1f20 <vfprintf+0x11a>
    1f14:	83 37       	cpi	r24, 0x73	; 115
    1f16:	71 f0       	breq	.+28     	; 0x1f34 <vfprintf+0x12e>
    1f18:	83 35       	cpi	r24, 0x53	; 83
    1f1a:	09 f0       	breq	.+2      	; 0x1f1e <vfprintf+0x118>
    1f1c:	59 c0       	rjmp	.+178    	; 0x1fd0 <vfprintf+0x1ca>
    1f1e:	21 c0       	rjmp	.+66     	; 0x1f62 <vfprintf+0x15c>
    1f20:	f8 01       	movw	r30, r16
    1f22:	80 81       	ld	r24, Z
    1f24:	89 83       	std	Y+1, r24	; 0x01
    1f26:	0e 5f       	subi	r16, 0xFE	; 254
    1f28:	1f 4f       	sbci	r17, 0xFF	; 255
    1f2a:	88 24       	eor	r8, r8
    1f2c:	83 94       	inc	r8
    1f2e:	91 2c       	mov	r9, r1
    1f30:	53 01       	movw	r10, r6
    1f32:	13 c0       	rjmp	.+38     	; 0x1f5a <vfprintf+0x154>
    1f34:	28 01       	movw	r4, r16
    1f36:	f2 e0       	ldi	r31, 0x02	; 2
    1f38:	4f 0e       	add	r4, r31
    1f3a:	51 1c       	adc	r5, r1
    1f3c:	f8 01       	movw	r30, r16
    1f3e:	a0 80       	ld	r10, Z
    1f40:	b1 80       	ldd	r11, Z+1	; 0x01
    1f42:	36 fe       	sbrs	r3, 6
    1f44:	03 c0       	rjmp	.+6      	; 0x1f4c <vfprintf+0x146>
    1f46:	69 2d       	mov	r22, r9
    1f48:	70 e0       	ldi	r23, 0x00	; 0
    1f4a:	02 c0       	rjmp	.+4      	; 0x1f50 <vfprintf+0x14a>
    1f4c:	6f ef       	ldi	r22, 0xFF	; 255
    1f4e:	7f ef       	ldi	r23, 0xFF	; 255
    1f50:	c5 01       	movw	r24, r10
    1f52:	0e 94 ef 10 	call	0x21de	; 0x21de <strnlen>
    1f56:	4c 01       	movw	r8, r24
    1f58:	82 01       	movw	r16, r4
    1f5a:	f3 2d       	mov	r31, r3
    1f5c:	ff 77       	andi	r31, 0x7F	; 127
    1f5e:	3f 2e       	mov	r3, r31
    1f60:	16 c0       	rjmp	.+44     	; 0x1f8e <vfprintf+0x188>
    1f62:	28 01       	movw	r4, r16
    1f64:	22 e0       	ldi	r18, 0x02	; 2
    1f66:	42 0e       	add	r4, r18
    1f68:	51 1c       	adc	r5, r1
    1f6a:	f8 01       	movw	r30, r16
    1f6c:	a0 80       	ld	r10, Z
    1f6e:	b1 80       	ldd	r11, Z+1	; 0x01
    1f70:	36 fe       	sbrs	r3, 6
    1f72:	03 c0       	rjmp	.+6      	; 0x1f7a <vfprintf+0x174>
    1f74:	69 2d       	mov	r22, r9
    1f76:	70 e0       	ldi	r23, 0x00	; 0
    1f78:	02 c0       	rjmp	.+4      	; 0x1f7e <vfprintf+0x178>
    1f7a:	6f ef       	ldi	r22, 0xFF	; 255
    1f7c:	7f ef       	ldi	r23, 0xFF	; 255
    1f7e:	c5 01       	movw	r24, r10
    1f80:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <strnlen_P>
    1f84:	4c 01       	movw	r8, r24
    1f86:	f3 2d       	mov	r31, r3
    1f88:	f0 68       	ori	r31, 0x80	; 128
    1f8a:	3f 2e       	mov	r3, r31
    1f8c:	82 01       	movw	r16, r4
    1f8e:	33 fc       	sbrc	r3, 3
    1f90:	1b c0       	rjmp	.+54     	; 0x1fc8 <vfprintf+0x1c2>
    1f92:	82 2d       	mov	r24, r2
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	88 16       	cp	r8, r24
    1f98:	99 06       	cpc	r9, r25
    1f9a:	b0 f4       	brcc	.+44     	; 0x1fc8 <vfprintf+0x1c2>
    1f9c:	b6 01       	movw	r22, r12
    1f9e:	80 e2       	ldi	r24, 0x20	; 32
    1fa0:	90 e0       	ldi	r25, 0x00	; 0
    1fa2:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    1fa6:	2a 94       	dec	r2
    1fa8:	f4 cf       	rjmp	.-24     	; 0x1f92 <vfprintf+0x18c>
    1faa:	f5 01       	movw	r30, r10
    1fac:	37 fc       	sbrc	r3, 7
    1fae:	85 91       	lpm	r24, Z+
    1fb0:	37 fe       	sbrs	r3, 7
    1fb2:	81 91       	ld	r24, Z+
    1fb4:	5f 01       	movw	r10, r30
    1fb6:	b6 01       	movw	r22, r12
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    1fbe:	21 10       	cpse	r2, r1
    1fc0:	2a 94       	dec	r2
    1fc2:	21 e0       	ldi	r18, 0x01	; 1
    1fc4:	82 1a       	sub	r8, r18
    1fc6:	91 08       	sbc	r9, r1
    1fc8:	81 14       	cp	r8, r1
    1fca:	91 04       	cpc	r9, r1
    1fcc:	71 f7       	brne	.-36     	; 0x1faa <vfprintf+0x1a4>
    1fce:	e8 c0       	rjmp	.+464    	; 0x21a0 <vfprintf+0x39a>
    1fd0:	84 36       	cpi	r24, 0x64	; 100
    1fd2:	11 f0       	breq	.+4      	; 0x1fd8 <vfprintf+0x1d2>
    1fd4:	89 36       	cpi	r24, 0x69	; 105
    1fd6:	41 f5       	brne	.+80     	; 0x2028 <vfprintf+0x222>
    1fd8:	f8 01       	movw	r30, r16
    1fda:	37 fe       	sbrs	r3, 7
    1fdc:	07 c0       	rjmp	.+14     	; 0x1fec <vfprintf+0x1e6>
    1fde:	60 81       	ld	r22, Z
    1fe0:	71 81       	ldd	r23, Z+1	; 0x01
    1fe2:	82 81       	ldd	r24, Z+2	; 0x02
    1fe4:	93 81       	ldd	r25, Z+3	; 0x03
    1fe6:	0c 5f       	subi	r16, 0xFC	; 252
    1fe8:	1f 4f       	sbci	r17, 0xFF	; 255
    1fea:	08 c0       	rjmp	.+16     	; 0x1ffc <vfprintf+0x1f6>
    1fec:	60 81       	ld	r22, Z
    1fee:	71 81       	ldd	r23, Z+1	; 0x01
    1ff0:	07 2e       	mov	r0, r23
    1ff2:	00 0c       	add	r0, r0
    1ff4:	88 0b       	sbc	r24, r24
    1ff6:	99 0b       	sbc	r25, r25
    1ff8:	0e 5f       	subi	r16, 0xFE	; 254
    1ffa:	1f 4f       	sbci	r17, 0xFF	; 255
    1ffc:	f3 2d       	mov	r31, r3
    1ffe:	ff 76       	andi	r31, 0x6F	; 111
    2000:	3f 2e       	mov	r3, r31
    2002:	97 ff       	sbrs	r25, 7
    2004:	09 c0       	rjmp	.+18     	; 0x2018 <vfprintf+0x212>
    2006:	90 95       	com	r25
    2008:	80 95       	com	r24
    200a:	70 95       	com	r23
    200c:	61 95       	neg	r22
    200e:	7f 4f       	sbci	r23, 0xFF	; 255
    2010:	8f 4f       	sbci	r24, 0xFF	; 255
    2012:	9f 4f       	sbci	r25, 0xFF	; 255
    2014:	f0 68       	ori	r31, 0x80	; 128
    2016:	3f 2e       	mov	r3, r31
    2018:	2a e0       	ldi	r18, 0x0A	; 10
    201a:	30 e0       	ldi	r19, 0x00	; 0
    201c:	a3 01       	movw	r20, r6
    201e:	0e 94 36 11 	call	0x226c	; 0x226c <__ultoa_invert>
    2022:	88 2e       	mov	r8, r24
    2024:	86 18       	sub	r8, r6
    2026:	45 c0       	rjmp	.+138    	; 0x20b2 <vfprintf+0x2ac>
    2028:	85 37       	cpi	r24, 0x75	; 117
    202a:	31 f4       	brne	.+12     	; 0x2038 <vfprintf+0x232>
    202c:	23 2d       	mov	r18, r3
    202e:	2f 7e       	andi	r18, 0xEF	; 239
    2030:	b2 2e       	mov	r11, r18
    2032:	2a e0       	ldi	r18, 0x0A	; 10
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	25 c0       	rjmp	.+74     	; 0x2082 <vfprintf+0x27c>
    2038:	93 2d       	mov	r25, r3
    203a:	99 7f       	andi	r25, 0xF9	; 249
    203c:	b9 2e       	mov	r11, r25
    203e:	8f 36       	cpi	r24, 0x6F	; 111
    2040:	c1 f0       	breq	.+48     	; 0x2072 <vfprintf+0x26c>
    2042:	18 f4       	brcc	.+6      	; 0x204a <vfprintf+0x244>
    2044:	88 35       	cpi	r24, 0x58	; 88
    2046:	79 f0       	breq	.+30     	; 0x2066 <vfprintf+0x260>
    2048:	b5 c0       	rjmp	.+362    	; 0x21b4 <vfprintf+0x3ae>
    204a:	80 37       	cpi	r24, 0x70	; 112
    204c:	19 f0       	breq	.+6      	; 0x2054 <vfprintf+0x24e>
    204e:	88 37       	cpi	r24, 0x78	; 120
    2050:	21 f0       	breq	.+8      	; 0x205a <vfprintf+0x254>
    2052:	b0 c0       	rjmp	.+352    	; 0x21b4 <vfprintf+0x3ae>
    2054:	e9 2f       	mov	r30, r25
    2056:	e0 61       	ori	r30, 0x10	; 16
    2058:	be 2e       	mov	r11, r30
    205a:	b4 fe       	sbrs	r11, 4
    205c:	0d c0       	rjmp	.+26     	; 0x2078 <vfprintf+0x272>
    205e:	fb 2d       	mov	r31, r11
    2060:	f4 60       	ori	r31, 0x04	; 4
    2062:	bf 2e       	mov	r11, r31
    2064:	09 c0       	rjmp	.+18     	; 0x2078 <vfprintf+0x272>
    2066:	34 fe       	sbrs	r3, 4
    2068:	0a c0       	rjmp	.+20     	; 0x207e <vfprintf+0x278>
    206a:	29 2f       	mov	r18, r25
    206c:	26 60       	ori	r18, 0x06	; 6
    206e:	b2 2e       	mov	r11, r18
    2070:	06 c0       	rjmp	.+12     	; 0x207e <vfprintf+0x278>
    2072:	28 e0       	ldi	r18, 0x08	; 8
    2074:	30 e0       	ldi	r19, 0x00	; 0
    2076:	05 c0       	rjmp	.+10     	; 0x2082 <vfprintf+0x27c>
    2078:	20 e1       	ldi	r18, 0x10	; 16
    207a:	30 e0       	ldi	r19, 0x00	; 0
    207c:	02 c0       	rjmp	.+4      	; 0x2082 <vfprintf+0x27c>
    207e:	20 e1       	ldi	r18, 0x10	; 16
    2080:	32 e0       	ldi	r19, 0x02	; 2
    2082:	f8 01       	movw	r30, r16
    2084:	b7 fe       	sbrs	r11, 7
    2086:	07 c0       	rjmp	.+14     	; 0x2096 <vfprintf+0x290>
    2088:	60 81       	ld	r22, Z
    208a:	71 81       	ldd	r23, Z+1	; 0x01
    208c:	82 81       	ldd	r24, Z+2	; 0x02
    208e:	93 81       	ldd	r25, Z+3	; 0x03
    2090:	0c 5f       	subi	r16, 0xFC	; 252
    2092:	1f 4f       	sbci	r17, 0xFF	; 255
    2094:	06 c0       	rjmp	.+12     	; 0x20a2 <vfprintf+0x29c>
    2096:	60 81       	ld	r22, Z
    2098:	71 81       	ldd	r23, Z+1	; 0x01
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	0e 5f       	subi	r16, 0xFE	; 254
    20a0:	1f 4f       	sbci	r17, 0xFF	; 255
    20a2:	a3 01       	movw	r20, r6
    20a4:	0e 94 36 11 	call	0x226c	; 0x226c <__ultoa_invert>
    20a8:	88 2e       	mov	r8, r24
    20aa:	86 18       	sub	r8, r6
    20ac:	fb 2d       	mov	r31, r11
    20ae:	ff 77       	andi	r31, 0x7F	; 127
    20b0:	3f 2e       	mov	r3, r31
    20b2:	36 fe       	sbrs	r3, 6
    20b4:	0d c0       	rjmp	.+26     	; 0x20d0 <vfprintf+0x2ca>
    20b6:	23 2d       	mov	r18, r3
    20b8:	2e 7f       	andi	r18, 0xFE	; 254
    20ba:	a2 2e       	mov	r10, r18
    20bc:	89 14       	cp	r8, r9
    20be:	58 f4       	brcc	.+22     	; 0x20d6 <vfprintf+0x2d0>
    20c0:	34 fe       	sbrs	r3, 4
    20c2:	0b c0       	rjmp	.+22     	; 0x20da <vfprintf+0x2d4>
    20c4:	32 fc       	sbrc	r3, 2
    20c6:	09 c0       	rjmp	.+18     	; 0x20da <vfprintf+0x2d4>
    20c8:	83 2d       	mov	r24, r3
    20ca:	8e 7e       	andi	r24, 0xEE	; 238
    20cc:	a8 2e       	mov	r10, r24
    20ce:	05 c0       	rjmp	.+10     	; 0x20da <vfprintf+0x2d4>
    20d0:	b8 2c       	mov	r11, r8
    20d2:	a3 2c       	mov	r10, r3
    20d4:	03 c0       	rjmp	.+6      	; 0x20dc <vfprintf+0x2d6>
    20d6:	b8 2c       	mov	r11, r8
    20d8:	01 c0       	rjmp	.+2      	; 0x20dc <vfprintf+0x2d6>
    20da:	b9 2c       	mov	r11, r9
    20dc:	a4 fe       	sbrs	r10, 4
    20de:	0f c0       	rjmp	.+30     	; 0x20fe <vfprintf+0x2f8>
    20e0:	fe 01       	movw	r30, r28
    20e2:	e8 0d       	add	r30, r8
    20e4:	f1 1d       	adc	r31, r1
    20e6:	80 81       	ld	r24, Z
    20e8:	80 33       	cpi	r24, 0x30	; 48
    20ea:	21 f4       	brne	.+8      	; 0x20f4 <vfprintf+0x2ee>
    20ec:	9a 2d       	mov	r25, r10
    20ee:	99 7e       	andi	r25, 0xE9	; 233
    20f0:	a9 2e       	mov	r10, r25
    20f2:	09 c0       	rjmp	.+18     	; 0x2106 <vfprintf+0x300>
    20f4:	a2 fe       	sbrs	r10, 2
    20f6:	06 c0       	rjmp	.+12     	; 0x2104 <vfprintf+0x2fe>
    20f8:	b3 94       	inc	r11
    20fa:	b3 94       	inc	r11
    20fc:	04 c0       	rjmp	.+8      	; 0x2106 <vfprintf+0x300>
    20fe:	8a 2d       	mov	r24, r10
    2100:	86 78       	andi	r24, 0x86	; 134
    2102:	09 f0       	breq	.+2      	; 0x2106 <vfprintf+0x300>
    2104:	b3 94       	inc	r11
    2106:	a3 fc       	sbrc	r10, 3
    2108:	11 c0       	rjmp	.+34     	; 0x212c <vfprintf+0x326>
    210a:	a0 fe       	sbrs	r10, 0
    210c:	06 c0       	rjmp	.+12     	; 0x211a <vfprintf+0x314>
    210e:	b2 14       	cp	r11, r2
    2110:	88 f4       	brcc	.+34     	; 0x2134 <vfprintf+0x32e>
    2112:	28 0c       	add	r2, r8
    2114:	92 2c       	mov	r9, r2
    2116:	9b 18       	sub	r9, r11
    2118:	0e c0       	rjmp	.+28     	; 0x2136 <vfprintf+0x330>
    211a:	b2 14       	cp	r11, r2
    211c:	60 f4       	brcc	.+24     	; 0x2136 <vfprintf+0x330>
    211e:	b6 01       	movw	r22, r12
    2120:	80 e2       	ldi	r24, 0x20	; 32
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    2128:	b3 94       	inc	r11
    212a:	f7 cf       	rjmp	.-18     	; 0x211a <vfprintf+0x314>
    212c:	b2 14       	cp	r11, r2
    212e:	18 f4       	brcc	.+6      	; 0x2136 <vfprintf+0x330>
    2130:	2b 18       	sub	r2, r11
    2132:	02 c0       	rjmp	.+4      	; 0x2138 <vfprintf+0x332>
    2134:	98 2c       	mov	r9, r8
    2136:	21 2c       	mov	r2, r1
    2138:	a4 fe       	sbrs	r10, 4
    213a:	10 c0       	rjmp	.+32     	; 0x215c <vfprintf+0x356>
    213c:	b6 01       	movw	r22, r12
    213e:	80 e3       	ldi	r24, 0x30	; 48
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    2146:	a2 fe       	sbrs	r10, 2
    2148:	17 c0       	rjmp	.+46     	; 0x2178 <vfprintf+0x372>
    214a:	a1 fc       	sbrc	r10, 1
    214c:	03 c0       	rjmp	.+6      	; 0x2154 <vfprintf+0x34e>
    214e:	88 e7       	ldi	r24, 0x78	; 120
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	02 c0       	rjmp	.+4      	; 0x2158 <vfprintf+0x352>
    2154:	88 e5       	ldi	r24, 0x58	; 88
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	b6 01       	movw	r22, r12
    215a:	0c c0       	rjmp	.+24     	; 0x2174 <vfprintf+0x36e>
    215c:	8a 2d       	mov	r24, r10
    215e:	86 78       	andi	r24, 0x86	; 134
    2160:	59 f0       	breq	.+22     	; 0x2178 <vfprintf+0x372>
    2162:	a1 fe       	sbrs	r10, 1
    2164:	02 c0       	rjmp	.+4      	; 0x216a <vfprintf+0x364>
    2166:	8b e2       	ldi	r24, 0x2B	; 43
    2168:	01 c0       	rjmp	.+2      	; 0x216c <vfprintf+0x366>
    216a:	80 e2       	ldi	r24, 0x20	; 32
    216c:	a7 fc       	sbrc	r10, 7
    216e:	8d e2       	ldi	r24, 0x2D	; 45
    2170:	b6 01       	movw	r22, r12
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    2178:	89 14       	cp	r8, r9
    217a:	38 f4       	brcc	.+14     	; 0x218a <vfprintf+0x384>
    217c:	b6 01       	movw	r22, r12
    217e:	80 e3       	ldi	r24, 0x30	; 48
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    2186:	9a 94       	dec	r9
    2188:	f7 cf       	rjmp	.-18     	; 0x2178 <vfprintf+0x372>
    218a:	8a 94       	dec	r8
    218c:	f3 01       	movw	r30, r6
    218e:	e8 0d       	add	r30, r8
    2190:	f1 1d       	adc	r31, r1
    2192:	80 81       	ld	r24, Z
    2194:	b6 01       	movw	r22, r12
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    219c:	81 10       	cpse	r8, r1
    219e:	f5 cf       	rjmp	.-22     	; 0x218a <vfprintf+0x384>
    21a0:	22 20       	and	r2, r2
    21a2:	09 f4       	brne	.+2      	; 0x21a6 <vfprintf+0x3a0>
    21a4:	42 ce       	rjmp	.-892    	; 0x1e2a <vfprintf+0x24>
    21a6:	b6 01       	movw	r22, r12
    21a8:	80 e2       	ldi	r24, 0x20	; 32
    21aa:	90 e0       	ldi	r25, 0x00	; 0
    21ac:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <fputc>
    21b0:	2a 94       	dec	r2
    21b2:	f6 cf       	rjmp	.-20     	; 0x21a0 <vfprintf+0x39a>
    21b4:	f6 01       	movw	r30, r12
    21b6:	86 81       	ldd	r24, Z+6	; 0x06
    21b8:	97 81       	ldd	r25, Z+7	; 0x07
    21ba:	02 c0       	rjmp	.+4      	; 0x21c0 <vfprintf+0x3ba>
    21bc:	8f ef       	ldi	r24, 0xFF	; 255
    21be:	9f ef       	ldi	r25, 0xFF	; 255
    21c0:	2b 96       	adiw	r28, 0x0b	; 11
    21c2:	e2 e1       	ldi	r30, 0x12	; 18
    21c4:	0c 94 b0 11 	jmp	0x2360	; 0x2360 <__epilogue_restores__>

000021c8 <strnlen_P>:
    21c8:	fc 01       	movw	r30, r24
    21ca:	05 90       	lpm	r0, Z+
    21cc:	61 50       	subi	r22, 0x01	; 1
    21ce:	70 40       	sbci	r23, 0x00	; 0
    21d0:	01 10       	cpse	r0, r1
    21d2:	d8 f7       	brcc	.-10     	; 0x21ca <strnlen_P+0x2>
    21d4:	80 95       	com	r24
    21d6:	90 95       	com	r25
    21d8:	8e 0f       	add	r24, r30
    21da:	9f 1f       	adc	r25, r31
    21dc:	08 95       	ret

000021de <strnlen>:
    21de:	fc 01       	movw	r30, r24
    21e0:	61 50       	subi	r22, 0x01	; 1
    21e2:	70 40       	sbci	r23, 0x00	; 0
    21e4:	01 90       	ld	r0, Z+
    21e6:	01 10       	cpse	r0, r1
    21e8:	d8 f7       	brcc	.-10     	; 0x21e0 <strnlen+0x2>
    21ea:	80 95       	com	r24
    21ec:	90 95       	com	r25
    21ee:	8e 0f       	add	r24, r30
    21f0:	9f 1f       	adc	r25, r31
    21f2:	08 95       	ret

000021f4 <fputc>:
    21f4:	0f 93       	push	r16
    21f6:	1f 93       	push	r17
    21f8:	cf 93       	push	r28
    21fa:	df 93       	push	r29
    21fc:	fb 01       	movw	r30, r22
    21fe:	23 81       	ldd	r18, Z+3	; 0x03
    2200:	21 fd       	sbrc	r18, 1
    2202:	03 c0       	rjmp	.+6      	; 0x220a <fputc+0x16>
    2204:	8f ef       	ldi	r24, 0xFF	; 255
    2206:	9f ef       	ldi	r25, 0xFF	; 255
    2208:	2c c0       	rjmp	.+88     	; 0x2262 <fputc+0x6e>
    220a:	22 ff       	sbrs	r18, 2
    220c:	16 c0       	rjmp	.+44     	; 0x223a <fputc+0x46>
    220e:	46 81       	ldd	r20, Z+6	; 0x06
    2210:	57 81       	ldd	r21, Z+7	; 0x07
    2212:	24 81       	ldd	r18, Z+4	; 0x04
    2214:	35 81       	ldd	r19, Z+5	; 0x05
    2216:	42 17       	cp	r20, r18
    2218:	53 07       	cpc	r21, r19
    221a:	44 f4       	brge	.+16     	; 0x222c <fputc+0x38>
    221c:	a0 81       	ld	r26, Z
    221e:	b1 81       	ldd	r27, Z+1	; 0x01
    2220:	9d 01       	movw	r18, r26
    2222:	2f 5f       	subi	r18, 0xFF	; 255
    2224:	3f 4f       	sbci	r19, 0xFF	; 255
    2226:	31 83       	std	Z+1, r19	; 0x01
    2228:	20 83       	st	Z, r18
    222a:	8c 93       	st	X, r24
    222c:	26 81       	ldd	r18, Z+6	; 0x06
    222e:	37 81       	ldd	r19, Z+7	; 0x07
    2230:	2f 5f       	subi	r18, 0xFF	; 255
    2232:	3f 4f       	sbci	r19, 0xFF	; 255
    2234:	37 83       	std	Z+7, r19	; 0x07
    2236:	26 83       	std	Z+6, r18	; 0x06
    2238:	14 c0       	rjmp	.+40     	; 0x2262 <fputc+0x6e>
    223a:	8b 01       	movw	r16, r22
    223c:	ec 01       	movw	r28, r24
    223e:	fb 01       	movw	r30, r22
    2240:	00 84       	ldd	r0, Z+8	; 0x08
    2242:	f1 85       	ldd	r31, Z+9	; 0x09
    2244:	e0 2d       	mov	r30, r0
    2246:	09 95       	icall
    2248:	89 2b       	or	r24, r25
    224a:	e1 f6       	brne	.-72     	; 0x2204 <fputc+0x10>
    224c:	d8 01       	movw	r26, r16
    224e:	16 96       	adiw	r26, 0x06	; 6
    2250:	8d 91       	ld	r24, X+
    2252:	9c 91       	ld	r25, X
    2254:	17 97       	sbiw	r26, 0x07	; 7
    2256:	01 96       	adiw	r24, 0x01	; 1
    2258:	17 96       	adiw	r26, 0x07	; 7
    225a:	9c 93       	st	X, r25
    225c:	8e 93       	st	-X, r24
    225e:	16 97       	sbiw	r26, 0x06	; 6
    2260:	ce 01       	movw	r24, r28
    2262:	df 91       	pop	r29
    2264:	cf 91       	pop	r28
    2266:	1f 91       	pop	r17
    2268:	0f 91       	pop	r16
    226a:	08 95       	ret

0000226c <__ultoa_invert>:
    226c:	fa 01       	movw	r30, r20
    226e:	aa 27       	eor	r26, r26
    2270:	28 30       	cpi	r18, 0x08	; 8
    2272:	51 f1       	breq	.+84     	; 0x22c8 <__ultoa_invert+0x5c>
    2274:	20 31       	cpi	r18, 0x10	; 16
    2276:	81 f1       	breq	.+96     	; 0x22d8 <__ultoa_invert+0x6c>
    2278:	e8 94       	clt
    227a:	6f 93       	push	r22
    227c:	6e 7f       	andi	r22, 0xFE	; 254
    227e:	6e 5f       	subi	r22, 0xFE	; 254
    2280:	7f 4f       	sbci	r23, 0xFF	; 255
    2282:	8f 4f       	sbci	r24, 0xFF	; 255
    2284:	9f 4f       	sbci	r25, 0xFF	; 255
    2286:	af 4f       	sbci	r26, 0xFF	; 255
    2288:	b1 e0       	ldi	r27, 0x01	; 1
    228a:	3e d0       	rcall	.+124    	; 0x2308 <__ultoa_invert+0x9c>
    228c:	b4 e0       	ldi	r27, 0x04	; 4
    228e:	3c d0       	rcall	.+120    	; 0x2308 <__ultoa_invert+0x9c>
    2290:	67 0f       	add	r22, r23
    2292:	78 1f       	adc	r23, r24
    2294:	89 1f       	adc	r24, r25
    2296:	9a 1f       	adc	r25, r26
    2298:	a1 1d       	adc	r26, r1
    229a:	68 0f       	add	r22, r24
    229c:	79 1f       	adc	r23, r25
    229e:	8a 1f       	adc	r24, r26
    22a0:	91 1d       	adc	r25, r1
    22a2:	a1 1d       	adc	r26, r1
    22a4:	6a 0f       	add	r22, r26
    22a6:	71 1d       	adc	r23, r1
    22a8:	81 1d       	adc	r24, r1
    22aa:	91 1d       	adc	r25, r1
    22ac:	a1 1d       	adc	r26, r1
    22ae:	20 d0       	rcall	.+64     	; 0x22f0 <__ultoa_invert+0x84>
    22b0:	09 f4       	brne	.+2      	; 0x22b4 <__ultoa_invert+0x48>
    22b2:	68 94       	set
    22b4:	3f 91       	pop	r19
    22b6:	2a e0       	ldi	r18, 0x0A	; 10
    22b8:	26 9f       	mul	r18, r22
    22ba:	11 24       	eor	r1, r1
    22bc:	30 19       	sub	r19, r0
    22be:	30 5d       	subi	r19, 0xD0	; 208
    22c0:	31 93       	st	Z+, r19
    22c2:	de f6       	brtc	.-74     	; 0x227a <__ultoa_invert+0xe>
    22c4:	cf 01       	movw	r24, r30
    22c6:	08 95       	ret
    22c8:	46 2f       	mov	r20, r22
    22ca:	47 70       	andi	r20, 0x07	; 7
    22cc:	40 5d       	subi	r20, 0xD0	; 208
    22ce:	41 93       	st	Z+, r20
    22d0:	b3 e0       	ldi	r27, 0x03	; 3
    22d2:	0f d0       	rcall	.+30     	; 0x22f2 <__ultoa_invert+0x86>
    22d4:	c9 f7       	brne	.-14     	; 0x22c8 <__ultoa_invert+0x5c>
    22d6:	f6 cf       	rjmp	.-20     	; 0x22c4 <__ultoa_invert+0x58>
    22d8:	46 2f       	mov	r20, r22
    22da:	4f 70       	andi	r20, 0x0F	; 15
    22dc:	40 5d       	subi	r20, 0xD0	; 208
    22de:	4a 33       	cpi	r20, 0x3A	; 58
    22e0:	18 f0       	brcs	.+6      	; 0x22e8 <__ultoa_invert+0x7c>
    22e2:	49 5d       	subi	r20, 0xD9	; 217
    22e4:	31 fd       	sbrc	r19, 1
    22e6:	40 52       	subi	r20, 0x20	; 32
    22e8:	41 93       	st	Z+, r20
    22ea:	02 d0       	rcall	.+4      	; 0x22f0 <__ultoa_invert+0x84>
    22ec:	a9 f7       	brne	.-22     	; 0x22d8 <__ultoa_invert+0x6c>
    22ee:	ea cf       	rjmp	.-44     	; 0x22c4 <__ultoa_invert+0x58>
    22f0:	b4 e0       	ldi	r27, 0x04	; 4
    22f2:	a6 95       	lsr	r26
    22f4:	97 95       	ror	r25
    22f6:	87 95       	ror	r24
    22f8:	77 95       	ror	r23
    22fa:	67 95       	ror	r22
    22fc:	ba 95       	dec	r27
    22fe:	c9 f7       	brne	.-14     	; 0x22f2 <__ultoa_invert+0x86>
    2300:	00 97       	sbiw	r24, 0x00	; 0
    2302:	61 05       	cpc	r22, r1
    2304:	71 05       	cpc	r23, r1
    2306:	08 95       	ret
    2308:	9b 01       	movw	r18, r22
    230a:	ac 01       	movw	r20, r24
    230c:	0a 2e       	mov	r0, r26
    230e:	06 94       	lsr	r0
    2310:	57 95       	ror	r21
    2312:	47 95       	ror	r20
    2314:	37 95       	ror	r19
    2316:	27 95       	ror	r18
    2318:	ba 95       	dec	r27
    231a:	c9 f7       	brne	.-14     	; 0x230e <__ultoa_invert+0xa2>
    231c:	62 0f       	add	r22, r18
    231e:	73 1f       	adc	r23, r19
    2320:	84 1f       	adc	r24, r20
    2322:	95 1f       	adc	r25, r21
    2324:	a0 1d       	adc	r26, r0
    2326:	08 95       	ret

00002328 <__prologue_saves__>:
    2328:	2f 92       	push	r2
    232a:	3f 92       	push	r3
    232c:	4f 92       	push	r4
    232e:	5f 92       	push	r5
    2330:	6f 92       	push	r6
    2332:	7f 92       	push	r7
    2334:	8f 92       	push	r8
    2336:	9f 92       	push	r9
    2338:	af 92       	push	r10
    233a:	bf 92       	push	r11
    233c:	cf 92       	push	r12
    233e:	df 92       	push	r13
    2340:	ef 92       	push	r14
    2342:	ff 92       	push	r15
    2344:	0f 93       	push	r16
    2346:	1f 93       	push	r17
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	cd b7       	in	r28, 0x3d	; 61
    234e:	de b7       	in	r29, 0x3e	; 62
    2350:	ca 1b       	sub	r28, r26
    2352:	db 0b       	sbc	r29, r27
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	de bf       	out	0x3e, r29	; 62
    235a:	0f be       	out	0x3f, r0	; 63
    235c:	cd bf       	out	0x3d, r28	; 61
    235e:	09 94       	ijmp

00002360 <__epilogue_restores__>:
    2360:	2a 88       	ldd	r2, Y+18	; 0x12
    2362:	39 88       	ldd	r3, Y+17	; 0x11
    2364:	48 88       	ldd	r4, Y+16	; 0x10
    2366:	5f 84       	ldd	r5, Y+15	; 0x0f
    2368:	6e 84       	ldd	r6, Y+14	; 0x0e
    236a:	7d 84       	ldd	r7, Y+13	; 0x0d
    236c:	8c 84       	ldd	r8, Y+12	; 0x0c
    236e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2370:	aa 84       	ldd	r10, Y+10	; 0x0a
    2372:	b9 84       	ldd	r11, Y+9	; 0x09
    2374:	c8 84       	ldd	r12, Y+8	; 0x08
    2376:	df 80       	ldd	r13, Y+7	; 0x07
    2378:	ee 80       	ldd	r14, Y+6	; 0x06
    237a:	fd 80       	ldd	r15, Y+5	; 0x05
    237c:	0c 81       	ldd	r16, Y+4	; 0x04
    237e:	1b 81       	ldd	r17, Y+3	; 0x03
    2380:	aa 81       	ldd	r26, Y+2	; 0x02
    2382:	b9 81       	ldd	r27, Y+1	; 0x01
    2384:	ce 0f       	add	r28, r30
    2386:	d1 1d       	adc	r29, r1
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	f8 94       	cli
    238c:	de bf       	out	0x3e, r29	; 62
    238e:	0f be       	out	0x3f, r0	; 63
    2390:	cd bf       	out	0x3d, r28	; 61
    2392:	ed 01       	movw	r28, r26
    2394:	08 95       	ret

00002396 <_exit>:
    2396:	f8 94       	cli

00002398 <__stop_program>:
    2398:	ff cf       	rjmp	.-2      	; 0x2398 <__stop_program>
